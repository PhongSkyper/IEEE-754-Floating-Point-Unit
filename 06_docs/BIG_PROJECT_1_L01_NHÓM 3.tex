\documentclass[12pt,a4paper]{report}

% ================== Unicode + tiếng Việt (XeLaTeX) ==================
\usepackage{fontspec}
\usepackage[main=english,vietnamese]{babel}
\babelprovide[import]{vietnamese}
\usepackage{amssymb}
% Font an toàn có sẵn trong TeX Live (giống Times)
\setsansfont{TeX Gyre Heros}
\babelfont[vietnamese]{rm}{TeX Gyre Termes}
\babelfont[vietnamese]{sf}{TeX Gyre Heros}
\babelfont[vietnamese]{tt}{DejaVu Sans Mono}
\usepackage{etoolbox} % nếu chưa có
% Trong preamble thêm:
\usepackage[titles]{tocloft}
\renewcommand{\cftchapfont}{\large\bfseries}
\renewcommand{\cftchappagefont}{\large\bfseries}
\usepackage{titlesec}
% ================== Page layout ======================
\usepackage[left=2.5cm,right=2.5cm,top=2cm,bottom=2.5cm]{geometry}
\setlength{\parindent}{0pt}
\raggedbottom
\usepackage{pdflscape}
% ================== Graphics & floats ================
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{colortbl}   % Hỗ trợ tô màu bảng
\usepackage{placeins}
% ================== Tables ===========================
\usepackage{booktabs}
\usepackage{array}
\usepackage{makecell}
\usepackage[table]{xcolor}
\usepackage{siunitx}
\usepackage{adjustbox}
\usepackage{float}
\usepackage{multirow}
% ================== Math =============================
\usepackage{amsmath,amssymb,amsthm}

% ================== Code listings ====================
\usepackage{listings}
\usepackage{titlesec}
% ================== Drawing & plots ==================
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% ================== Framed boxes =====================
\usepackage{mdframed}

\usepackage[colorlinks=true,
linkcolor=blue,   % màu cho link trong TOC, section, ref,...
urlcolor=blue]{hyperref}

%linkcolor=black: màu đen cho tham chiếu nội bộ
% citecolor=black: màu đen cho trích dẫn
% urlcolor=black: màu đen cho URL
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	citecolor=black,
	urlcolor=blue,
	 unicode, 
	 hidelinks
}


\makeatletter
% Giảm khoảng trắng trước Chapter từ 50pt xuống 10pt
\patchcmd{\@makechapterhead}{\vspace*{50\p@}}{\vspace*{10\p@}}{}{}
% (tuỳ thích đổi 10\p@ thành 0\p@, 5\p@, 20\p@,...)
\makeatother

\titleformat{\chapter}[display]
{\normalfont\bfseries\Huge}
{Chapter \thechapter}
{10pt}
{}  % phần code in nội dung title, để trống cũng được

% khoảng cách: {left}{before}{after}
\titlespacing*{\chapter}{0pt}{-2em}{1.5em}

% ================== Spacing & headings ===============
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{indentfirst}

% ================== ToC formatting ===================
\usepackage[titles]{tocloft}
\renewcommand{\cfttoctitlefont}{\large\bfseries}
\renewcommand{\cftdotsep}{1}
\setlength{\cftbeforesecskip}{0.25em}
\setlength{\cftbeforesubsecskip}{0.1em}
\setlength{\cftbeforesubsubsecskip}{0.1em}
\renewcommand{\cftsecfont}{\bfseries}
\renewcommand{\cftsecpagefont}{\bfseries}
\cftsetindents{section}{0em}{2.7em}
\cftsetindents{subsection}{1.5em}{3.4em}
\cftsetindents{subsubsection}{3.0em}{4.1em}

% ================== Header / footer ==================
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{} % clear defaults
\lhead{\fontsize{10}{13}\selectfont
\begin{tabular}{l l}
\raisebox{-0.4cm}{\includegraphics[scale=0.11]{logobk}} &
\makecell[l]{\texttt{University of Technology, Ho Chi Minh City}\\
\texttt{Faculty of Electrical-Electronics Engineering}}
\end{tabular}}

\lfoot{\fontsize{10}{13}\selectfont \texttt{Digital System Design and Verification - Semester 251 - L01 - Group 3}}
\cfoot{}
\rfoot{\fontsize{10}{13}\selectfont \texttt{Page \thepage/71}}
\renewcommand{\headrulewidth}{1.4pt}
\renewcommand{\footrulewidth}{1.4pt}
\setlength{\headheight}{30pt}


% ---------- Make sections top-level (no chapter numbering) ----------
\makeatletter
\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\makeatother

% ---------- Listings setup (SystemVerilog) ----------
\lstdefinelanguage{SystemVerilog}{
morekeywords=[1]{module,endmodule,input,output,inout,logic,wire,reg,always,always_ff,always_comb,
posedge,negedge,if,else,case,endcase,for,generate,endgenerate,begin,end,assign,
parameter,localparam,typedef,enum,struct,union,package,endpackage,import,class,
endclass,function,endfunction,task,endtask,interface,endinterface,modport,
timeunit,timeprecision,unique,priority,return,automatic},
% escape $ in keywords
morekeywords=[2]{\$display,\$finish,\$time,\$random},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]"
}
\lstset{
basicstyle=\ttfamily\small,
keywordstyle=\color{blue},
keywordstyle=[2]\color{teal},
commentstyle=\color{green!60!black},
stringstyle=\color{red!70!black},
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt,
tabsize=2,                 % <= SỬA: tabsize phải là số nguyên
showstringspaces=false,
breaklines=true,
frame=single,
language=SystemVerilog,
captionpos=b
}

% ---------- Metadata ----------
\title{Assisgnment Report}
\author{Nguyễn Thanh Phong}
\date{\today}
\newcommand{\course}{Introduction to IC Design (EE3201)}
\newcommand{\dept}{Department of Electronics}
\newcommand{\toolA}{Cadence Xcelium}
\newcommand{\toolB}{SimVision}

% ---------- Helpers ----------
\newcommand{\HRule}{\par\noindent\rule{\linewidth}{0.8pt}\par}
\newcommand{\HRuleGap}[1]{\HRule\vspace{#1}}

\begin{document}

% ================== COVER (TikZ border + info block) ==================
\onehalfspacing
\begin{titlepage}
\thispagestyle{empty}

% Border
\begin{tikzpicture}[remember picture,overlay,inner sep=0,outer sep=0]
\draw[blue!70!black,line width=4pt]
([xshift=-1.5cm,yshift=-2cm]current page.north east) coordinate (A) --
([xshift= 1.5cm,yshift=-2cm]current page.north west) coordinate (B) --
([xshift= 1.5cm,yshift= 2cm]current page.south west) coordinate (C) --
([xshift=-1.5cm,yshift= 2cm]current page.south east) coordinate (D) -- cycle;

\draw ([yshift=0.4cm,xshift=-0.4cm]A)--([yshift=0.4cm,xshift=0.4cm]B)--
([yshift=-0.4cm,xshift=0.4cm]B)--([yshift=-0.4cm,xshift=-0.4cm]B)--
([yshift=0.4cm,xshift=-0.4cm]C)--([yshift=0.4cm,xshift=0.4cm]C)--
([yshift=-0.4cm,xshift=0.4cm]C)--([yshift=-0.4cm,xshift=-0.4cm]D)--
([yshift=0.4cm,xshift=-0.4cm]D)--([yshift=0.4cm,xshift=0.4cm]D)--
([yshift=-0.4cm,xshift=0.4cm]A)--([yshift=-0.4cm,xshift=-0.4cm]A)--
([yshift=0.4cm,xshift=-0.4cm]A);

\draw ([yshift=-0.3cm,xshift=0.3cm]A)--([yshift=-0.3cm,xshift=-0.3cm]B)--
([yshift=0.3cm,xshift=-0.3cm]B)--([yshift=0.3cm,xshift=0.3cm]B)--
([yshift=-0.3cm,xshift=0.3cm]C)--([yshift=-0.3cm,xshift=-0.3cm]C)--
([yshift=0.3cm,xshift=-0.3cm]C)--([yshift=0.3cm,xshift=0.3cm]D)--
([yshift=-0.3cm,xshift=0.3cm]D)--([yshift=-0.3cm,xshift=-0.3cm]D)--
([yshift=0.3cm,xshift=-0.3cm]A)--([yshift=0.3cm,xshift=0.3cm]A)--
([yshift=-0.3cm,xshift=0.3cm]A);
\end{tikzpicture}

\begin{center}
{\large {VIETNAM NATIONAL UNIVERSITY, HO CHI MINH CITY}} \\
{\large {HO CHI MINH CITY UNIVERSITY OF TECHNOLOGY}} \\
{\normalsize {FACULTY OF ELECTRICAL-ELECTRONICS ENGINEERING}} \\
{\normalsize {DEPARTMENT OF ELECTRONICS}} \\
\vspace{1pt}

\includegraphics[scale=0.3]{logobk1}

{\LARGE \bf \textbf{ASSIGNMENT REPORT}}\\[0.3cm]
{%
	\fontsize{19.5pt}{22pt}\selectfont
	\bfseries
	DIGITAL SYSTEM DESIGN AND VERIFICATION (EE3213)\par
} \vspace{0.3cm}
{\large \textbf{Class:} L01  \textbf{- Group:} 3 \textbf{- Semester:} 251} \\[0.1cm]
\HRuleGap{0.1cm}
\Large{\textbf{BIG PROJECT 1:}} \textbf{\large FLOATING POINT ADDER AND SUBTRACTOR}
\HRuleGap{0.1cm}
\vspace{0.7cm}

\begin{spacing}{1.15}
{\fontsize{13pt}{13.5pt}\selectfont
\setlength{\tabcolsep}{6pt}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{rl}
\textbf{Semester:}   & 251 - 2025--2026 \\
\textbf{Tools:}      & Cadence Xcelium, SimVision, Genus \\[0.2em]
\textbf{Instructor:} & MSc. Nguyễn Trung Hiếu \\
\textbf{Student:}    & Lý Quốc Hoàng Minh -- 2312077 \\
& Nguyễn Thanh Phong -- 2312626 \\
\textbf{Date:}       & \today \\
\textbf{Project Source Files:} & \textcolor{blue}{\href{https://drive.google.com/drive/folders/1Eq1QB_7uaaXTqEnM3sOb4G58M3DVvnYS}{Google Drive}}
\\
\end{tabular}
}
\end{spacing}
\end{center}
\end{titlepage}

	\newpage
\begin{center}
\renewcommand{\arraystretch}{2}
\fontsize{10}{12}\selectfont
\textbf{TASK ASSIGNMENT TABLE} \\ [0.2cm]
\begin{tabular}{|c|c|l|c|}
\hline    
\textbf{Full Name} & \textbf{Student ID} & \hspace{1.25cm} \textbf{Task} & \textbf{Grading} \\ \hline

Lý Quốc Hoàng Minh & 2312077 & \makecell[l]{SystemVerilog Code (Unpack \& Precheck Block) \\ Synthesis \& Optimization }& 20$\%$ \\ \hline
Nguyễn Thanh Phong & 2312626 &  \makecell[l]{Architechture Design \\ SystemVerilog Code  (All Remaining Blocks) \\ Verification Strategy\\ FPGA Implementations \\ Synthesis \& Optimization\\ Report writing } & 100$\%$ \\ \hline
\end{tabular}
\end{center}

\begin{flushright}
\textit{Ho Chi Minh City, \today}
\end{flushright}


% ---- Front matter with pageanchor workaround ----
\pagenumbering{roman}
\hypersetup{pageanchor=false}
\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings
\clearpage
\hypersetup{pageanchor=true}
\pagenumbering{arabic}

% ====================================================
\chapter{INTRODUCTION \& OBJECTIVE}

\section{Introduction}
In digital systems, arithmetic operations on real numbers are typically implemented using 
the IEEE-754 floating-point standard. Unlike integer arithmetic, floating-point arithmetic 
can represent a very wide dynamic range of values, enabling precise computation of both 
very large and very small numbers. However, floating-point operations are considerably more 
complex than fixed-point or integer operations, because they must handle normalization, 
rounding, overflow, underflow, and various special cases such as \texttt{NaN}, 
$\pm\infty$, and $\pm0$. \\

In this project, a \textbf{32-bit floating-point adder and subtractor} (FPU) is designed 
according to the IEEE-754 single-precision format. The design is implemented entirely using 
\emph{combinational logic}—no clocked registers are involved—so that the result of the 
operation depends only on the current input values. The project requires not only a correct 
functional design but also verification through simulation, synthesis, and FPGA implementation. \\

The IEEE-754 single-precision format consists of three fields:
\begin{itemize}
	\item 1 sign bit ($S$)
	\item 8 exponent bits ($E$)
	\item 23 fraction (mantissa) bits ($M$)
\end{itemize}
A normalized floating-point number is represented as:
\[
(-1)^S \times 1.M \times 2^{(E-127)}
\]
This structure allows a trade-off between precision and range, enabling representation 
of values approximately from $10^{-38}$ to $10^{38}$. 

\section{Objectives}
The main goal of this project is to \textbf{design and verify a Floating-Point Unit (FPU)} 
that performs both addition and subtraction on 32-bit IEEE-754 single-precision numbers.
The design process follows a bottom-up hardware approach, where the overall FPU is divided 
into multiple functional sub-blocks.

Specific objectives include:
\begin{enumerate}
	\item \textbf{Design a combinational FPU} that performs addition and subtraction 
	accurately according to the IEEE-754 standard.
	\item \textbf{Implement key floating-point operations} including exponent alignment, 
	mantissa addition/subtraction, normalization, rounding, and packing of the final result.
	\item \textbf{Handle all special cases} such as overflow, underflow, $\pm0$, 
	subnormal numbers, $\pm\infty$, and \texttt{NaN}.
	\item \textbf{Verify the design} using a SystemVerilog testbench that applies 
	random input vectors and checks results against a software reference model.
	\item \textbf{Synthesize and implement} the design on an FPGA board (DE2) 
	to confirm functional correctness in hardware.
	\item \textbf{Analyze post-synthesis results} to ensure that the output has 
	minimal glitches and meets timing requirements.
\end{enumerate}

By completing these objectives, the project aims to deepen understanding of 
IEEE-754 arithmetic operations and their practical hardware realization. 

% ====================================================
\chapter{DESIGN STRATEGY}
\section{Overall Architecture}

The proposed Floating-Point Unit (FPU) features a hierarchical modular architecture designed to perform arithmetic operations in compliance with the IEEE-754 Single Precision standard. The design is decomposed into ten distinct functional blocks, ensuring a clear separation of concerns within the arithmetic pipeline:
\textit{Unpack \& Pretest}, \textit{Exponent Subtractor}, \textit{Swap Operation}, \textit{Alignment (Right Shift)}, \textit{Sign Computation}, \textit{Significand Add/Subtract}, \textit{Normalization} and \textit{Special Case Handling}. \\

Each block addresses a specific stage of the floating-point addition/subtraction algorithm. The top-level interface of the FPU is strictly combinational, defined as follows:

\begin{table}[H]
	\centering
	\caption{Top-Level Interface Specification}
	\label{tab:top_ios}
	\begin{tabular}{@{}l c c p{7cm}@{}}
		\toprule
		\textbf{Signal Name} & \textbf{Direction} & \textbf{Width} & \textbf{Description} \\
		\midrule
		\texttt{i\_a}        & Input  & 32 & Operand A (IEEE-754 Standard). \\
		\texttt{i\_b}        & Input  & 32 & Operand B (IEEE-754 Standard). \\
		\texttt{i\_add\_sub} & Input  & 1  & Operation Select (0: ADD, 1: SUB). \\
		\midrule
		\texttt{o\_z}        & Output & 32 & Result of the operation (IEEE-754). \\
		\texttt{o\_zero} & Output & 1  & Zero Exception Flag. \\
		\texttt{o\_overflow} & Output & 1  & Overflow Exception Flag. \\
		\texttt{o\_underflow} & Output & 1  & Underflow Exception Flag. \\
		\bottomrule
	\end{tabular}
\end{table}

The internal data flow implements the standard algorithm for floating-point arithmetic, processing data sequentially through the following stages:

\begin{enumerate}
	\item \textbf{Unpacking:} The 32-bit input vectors are split into Sign, Exponent, and Fraction fields.
	\item \textbf{Alignment:} The exponents are compared to determine the shift amount. The fraction of the smaller number is right-shifted to align with the larger number.
	\item \textbf{Arithmetic Operation:} The aligned fractions undergo addition or subtraction using two's complement logic where necessary.
	\item \textbf{Normalization:} The intermediate result is shifted (left or right) to restore the standard format ($1.F \times 2^E$), and the exponent is adjusted accordingly, then the final Sign, Exponent, and Fraction are reassembled into a 32-bit vector.
	\item \textbf{Special Case Handling:} Special cases (Zero, Infinity, NaN) and exceptions (Overflow, Underflow) are handled in this final stage.
\end{enumerate}

Figure~\textcolor{blue}{\ref{fig:top_level}} illustrates the complete datapath, demonstrating the interconnection between the ten functional blocks. The subsequent sections will provide a detailed analysis of the internal logic and implementation of each block.

\clearpage
\begin{landscape} % xoay cả trang
	\begin{figure}[p]
		\centering
		\includegraphics[width=1.6\textheight]{top_level_1.png}
		\caption{Top-Level Architecture of the Floating-Point Unit}
		\label{fig:top_level}
	\end{figure}
\end{landscape}
\clearpage


\section{Unpack \& Pretest}

This is the first functional block in the floating-point datapath. 
Its purpose is to decode the 32-bit IEEE-754 input operands 
(\texttt{A} and \texttt{B}) into their three basic components: 
sign, exponent, and fraction. In addition, it performs a precheck for 
special input patterns such as $\pm0$, $\pm\infty$, subnormal numbers, 
and \texttt{NaN} (Not a Number). 

\subsection{Interface Specification}

The table below details the input and output signals of the module. The block is designed to process two operands, A and B, simultaneously.

\begin{table}[h]
	\centering
	\caption{Signal definitions for the block}
	\label{tab:unpack_ios}
	\begin{tabular}{@{}l c c p{6cm}@{}}
		\toprule
		\textbf{Signal Name} & \textbf{Width} & \textbf{Dir} & \textbf{Description} \\
		\midrule
		\texttt{raw\_a}, \texttt{raw\_b} & 32 & In & IEEE 754 Single Precision floating-point input data. \\
		\midrule
		\texttt{sign\_a}, \texttt{sign\_b} & 1 & Out & Sign bit extracted from bit [31]. \\
		\texttt{exp\_a}, \texttt{exp\_b} & 8 & Out & Exponent field extracted from bits [30:23]. \\
		\texttt{frac\_a}, \texttt{frac\_b} & 23 & Out & Fraction (Mantissa) field extracted from bits [22:0]. \\
		\midrule
		\texttt{is\_zero\_a/b} & 1 & Out & Flag indicating a Zero value. \\
		\texttt{is\_inf\_a/b} & 1 & Out & Flag indicating an Infinity value. \\
		\texttt{is\_nan\_a/b} & 1 & Out & Flag indicating a NaN (Not a Number) value. \\
		\texttt{is\_subn\_a/b} & 1 & Out & Flag indicating a Subnormal value. \\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{Datapath Design}

The hardware architecture of the Unpack block is constructed using purely combinational logic, without any sequential elements, to ensure minimal latency. The detailed schematic is illustrated in Figure~\textcolor{blue}{\ref{fig:unpack_datapath}}.

\begin{figure}[H]
	\centering
 \includegraphics[width=1\textwidth]{unpack_pretest_datapath.png}
	\caption{Datapath Schematic of the Unpack \& Pretest block}
	\label{fig:unpack_datapath}
\end{figure}

The datapath design consists of two main components:
\begin{itemize}
	\item \textbf{Bit Slicing:} The 32-bit input bus is directly branched to split the data into three distinct standard fields: Sign (1 bit), Exponent (8 bits), and Fraction (23 bits) in Unpack Block.
	\item \textbf{Reduction Logic Network:} This network forms the core of the pre-test mechanism. The Exponent and Fraction buses pass through reduction logic operators to check for "all-zeros" or "all-ones" conditions:
	\begin{itemize}
		\item \textit{OR Reduction:} Used to detect if the bus contains at least one logic '1' (checks for non-zero values).
		\item \textit{AND Reduction:} Used to detect if all bits in the bus are logic '1' (checks for 0xFF values).
	\end{itemize}
\end{itemize}

\subsection{Functional Description}

The module classifies special values for both operands based on the IEEE 754-2008 standard. The detection logic is implemented as follows:

\begin{itemize}
	\item \textbf{Zero (\texttt{is\_zero}):} Triggered when both Exponent and Fraction are zero ($E=0 \land M=0$).
	\item \textbf{Subnormal (\texttt{is\_subn}):} Triggered when Exponent is zero but Fraction is non-zero ($E=0 \dot  M \neq 0$).
	\item \textbf{Infinity (\texttt{is\_inf}):} Triggered when Exponent is all ones and Fraction is zero ($E=\text{0xFF} \dot  M=0$).
	\item \textbf{NaN (\texttt{is\_nan}):} Triggered when Exponent is all ones and Fraction is non-zero ($E=\text{0xFF} \dot M \neq 0$).
\end{itemize}

Isolating these flags at the input stage simplifies the control logic, allowing the FPU to bypass complex arithmetic operations and immediately generate default results for special cases.






\section{Exponent Subtractor}

\subsection{Interface Specification}

The \texttt{fpu\_exponent\_subtractor} block compares the biased exponents of the two
single-precision operands. It receives the exponents from the \texttt{fpu\_unpack\_pretest}
stage, and produces the larger/smaller exponents, the (saturated) exponent difference, and
comparison flags. These outputs are used by the operand–swap logic, the alignment shifter,
and the exponent update path in later stages.

\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|p{6cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{exp\_a}    & Input  & 8  & Biased exponent of operand~A (from unpack/pretest). \\ \hline
		\texttt{exp\_b}    & Input  & 8  & Biased exponent of operand~B (from unpack/pretest). \\ \hline
		\texttt{exp\_max}  & Output & 8  & Larger of \texttt{exp\_a} and \texttt{exp\_b}. \\ \hline
		\texttt{exp\_min}  & Output & 8  & Smaller of \texttt{exp\_a} and \texttt{exp\_b}. \\ \hline
		\texttt{exp\_diff} & Output & 5  & Saturated absolute exponent difference, used as shift amount. \\ \hline
		\texttt{a\_ge\_b}  & Output & 1  & High if \texttt{exp\_a} is greater than or equal to \texttt{exp\_b}. \\ \hline
		\texttt{ex\_eq}    & Output & 1  & High if \texttt{exp\_a} and \texttt{exp\_b} are equal. \\ \hline
	\end{tabular}
	\caption{Interface of the \texttt{fpu\_exponent\_subtractor} block}
\end{table}

\subsection{Datapath Design}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{exponent_subtractor.png}
	\caption{Datapath of the exponent subtractor}
	\label{ffff}
\end{figure}

In Figure~\textcolor{blue}{\ref{ffff}}, two subtract paths compute \texttt{exp\_a - exp\_b}
and \texttt{exp\_b - exp\_a}; simple comparison logic chooses the larger exponent
(\texttt{exp\_max}), the smaller exponent (\texttt{exp\_min}), and the proper difference
vector. The absolute exponent difference is then truncated and saturated to 5~bits to form
\texttt{exp\_diff}, while zero-detect and comparator outputs generate \texttt{a\_ge\_b} and
\texttt{ex\_eq}.

\subsection{Functional Explanation}

The exponent subtractor performs three core functions:

\begin{itemize}
	\item \textbf{Compare exponents:} Evaluate whether \texttt{exp\_a} is greater than,
	equal to, or smaller than \texttt{exp\_b}, and set \texttt{a\_ge\_b} and
	\texttt{ex\_eq} accordingly.
	\item \textbf{Select max/min:} Route the larger exponent to \texttt{exp\_max} and the
	smaller exponent to \texttt{exp\_min} for use by the operand–swap and result
	exponent path.
	\item \textbf{Compute shift amount:} Generate the absolute exponent difference and
	saturate it to obtain \texttt{exp\_diff}, which directly controls the alignment
	right-shift of the smaller significand.
\end{itemize}

Because the block is combinational, all outputs update immediately when \texttt{exp\_a} or
\texttt{exp\_b} change, allowing it to share a pipeline stage with unpacking and alignment
preparation logic.



%==============================
\section{Swap Operation}

The Swap Operation block compares the magnitudes of two floating-point operands and, if
necessary, swaps them so that the operand with the larger magnitude is always treated as
the ``big'' operand in subsequent stages. This simplifies the alignment and sign–handling
logic in the adder/subtractor pipeline.

\subsection{Interface Specification}

This module receives normalized exponents and significands, together with precomputed
exponent comparison flags, from the Unpack \& Pretest and Exponent Subtractor blocks.
It outputs the reordered exponents and significands to the Alignment Shift Right block.
The interface signals are summarized in Table~\ref{tab:swap_io}.

\begin{table}[H]
	\centering
	\caption{Swap Operation Module I/O Signals}
	\label{tab:swap_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{exp\_a}, \texttt{exp\_b}       & Input  & 8  & Exponents of operands A and B. \\ \hline
		\texttt{sig\_a}, \texttt{sig\_b}       & Input  & 24 & Significands of operands A and B (including hidden bit). \\ \hline
		\texttt{a\_ge\_b\_exp}                 & Input  & 1  & A's exponent is greater than or equal to B's exponent. \\ \hline
		\texttt{ex\_eq}                        & Input  & 1  & Exponents of A and B are equal. \\ \hline
		\texttt{exp\_big}, \texttt{exp\_small} & Output & 8  & Exponents after swap (larger/smaller magnitude). \\ \hline
		\texttt{sig\_big}, \texttt{sig\_small} & Output & 24 & Significands after swap (larger/smaller magnitude). \\ \hline
		\texttt{a\_is\_big\_mag}               & Output & 1  & High if original operand A has the larger magnitude. \\ \hline
	\end{tabular}
\end{table}
\subsection{Datapath}

The datapath implementation is illustrated in Figure~\textcolor{blue}{\ref{fig:swap_datapath}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{swap_operands.png}
	\caption{Swap Operation Datapath}
	\label{fig:swap_datapath}
\end{figure}

The block is purely combinational and consists of:
\begin{itemize}
	\item A 24-bit comparator to compare the significand magnitudes;
	\item A 2:1 multiplexer that selects the final magnitude decision
	(based on exponent or significand comparison);
	\item Four 2:1 multiplexers that route exponents and significands to
	\texttt{(exp\_big, sig\_big)} and \texttt{(exp\_small, sig\_small)}.
\end{itemize}

\subsection{Functional Explanation}

The Swap Operation performs the following steps:
\begin{enumerate}
	\item The exponent comparison flags \texttt{a\_ge\_b\_exp} and \texttt{ex\_eq} are provided
	by the Exponent Subtractor block.
	\item If the exponents are equal (\texttt{ex\_eq = 1}), a 24-bit comparator determines
	which significand is larger.
	\item A 2:1 multiplexer selects the final ``A is larger'' decision: it uses the exponent
	comparison when \texttt{ex\_eq = 0}, and the significand comparison when
	\texttt{ex\_eq = 1}.
	\item Four output multiplexers then swap or pass through the exponents and significands so
	that the larger-magnitude operand always appears on the \texttt{(exp\_big, sig\_big)}
	outputs.
	\item The flag \texttt{a\_is\_big\_mag} records whether the original operand A was larger in
	magnitude, which is later used in the sign computation stage.
\end{enumerate}

With this ordering, the Alignment Shift Right block always shifts the smaller operand’s
significand, reducing hardware complexity and making the alignment behavior uniform.




%=======================================
\section{Alignment Shift Right}

The \texttt{fpu\_align\_shift\_right} block right–shifts the smaller operand’s significand by
the exponent difference and generates the guard, round, and sticky (GRS) bits required for
rounding in the normalization stage.

\subsection{Interface Specification}

This module receives the smaller-magnitude significand and the shift amount from the Swap
Operation and Exponent Subtractor blocks. It outputs the shifted significand (extended with
GRS bits) to the significand adder, together with the individual \texttt{guard}, \texttt{round},
and \texttt{sticky} flags. The interface is summarized in
Table~\textcolor{red}{\ref{tab:align_shift_io}}.

\begin{table}[H]
	\centering
	\caption{Alignment Shift Right Module I/O Signals}
	\label{tab:align_shift_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{sig\_small\_in}   & Input  &  24 & Smaller operand significand to be aligned. \\ \hline
		\texttt{shift\_amt}       & Input  & 5   & Right-shift amount (exponent difference, saturated to 0--31). \\ \hline
		\texttt{sig\_small\_out}  & Output & 27 & Aligned significand including GRS bits in the least-significant positions. \\ \hline
		\texttt{guard}            & Output & 1   & Guard bit extracted from the shifted significand. \\ \hline
		\texttt{round}            & Output & 1   & Round bit extracted from the shifted significand. \\ \hline
		\texttt{sticky}           & Output & 1   & Sticky bit: OR of the lowest kept bit and all bits shifted out. \\ \hline
	\end{tabular}
\end{table}

\subsection{Datapath}

The datapath is shown in Figure~\textcolor{blue}{\ref{fig:align_shift_datapath}}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{align_shift_right.png}
	\caption{Alignment Shift Right Datapath}
	\label{fig:align_shift_datapath}
\end{figure}

Internally, the input significand is first padded with three trailing zeros and mapped into
a 27-bit vector. This vector is then placed in the upper part of a 55-bit word
\texttt{out\_shifted\_full}, which is right–shifted by \texttt{shift\_amt} using a combinational
shift network (barrel shifter). The upper 27 bits of the shifted word form
\texttt{sig\_small\_out}. The guard and round bits are taken from the two least significant
bits of \texttt{sig\_small\_out}, while the sticky bit is computed as the OR of the lowest
kept bit and all lower-position bits in \texttt{out\_shifted\_full} that have been shifted
out of the retained range.

\subsection{Functional Explanation}

The Alignment Shift Right block operates as follows:
\begin{enumerate}
	\item Pad the smaller significand \texttt{sig\_small\_in} with three zeros at the LSB side
	to reserve space for GRS bits.
	\item Right–shift this padded value by \texttt{shift\_amt} using a combinational barrel
	shifter, producing \texttt{out\_shifted\_full}.
	\item Take the upper \texttt{SIG\_W+3} bits as \texttt{sig\_small\_out}; these contain the
	aligned significand plus three extra bits.
	\item Extract \texttt{guard} and \texttt{round} from the two least significant bits of
	\texttt{sig\_small\_out}.
	\item Form \texttt{sticky} as the OR of the lowest bit in \texttt{sig\_small\_out} and all
	remaining bits below it in \texttt{out\_shifted\_full}, capturing any non-zero bits
	that were shifted out.
\end{enumerate}

Because the design is fully combinational, the aligned significand and GRS bits are updated
immediately whenever the input significand or shift amount changes, allowing this block to
share a pipeline stage with the Swap Operation and exponent difference logic.




%=========================
\section{Sign Computation}

The \texttt{fpu\_sign\_computation} block determines the signs associated with the
larger and smaller magnitude operands and selects whether the significand datapath
performs addition or subtraction. It uses the original operand signs together with the
magnitude ordering information from the Swap Operation block.

\subsection{Interface Specification}

This module receives the sign of operand~A, the effective sign of operand~B
(after add/sub control), and the flag indicating whether A is the larger-magnitude
operand. It outputs the reordered signs (\texttt{sign\_big}, \texttt{sign\_small})
and a control signal \texttt{add\_path} that specifies whether the significands are
to be added or subtracted. The interface is summarized in
Table~\textcolor{red}{\ref{tab:sign_comp_io}}.

\begin{table}[H]
	\centering
	\caption{Sign Computation Module I/O Signals}
	\label{tab:sign_comp_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{sign\_a}       & Input  & 1 & Sign bit of operand~A (from unpack/pretest). \\ \hline
		\texttt{sign\_b\_eff}  & Input  & 1 & Effective sign of operand~B after add/sub control. \\ \hline
		\texttt{a\_is\_big}    & Input  & 1 & High if operand~A has larger magnitude (from Swap Operation). \\ \hline
		\texttt{sign\_big}     & Output & 1 & Sign bit corresponding to the larger-magnitude operand. \\ \hline
		\texttt{sign\_small}   & Output & 1 & Sign bit corresponding to the smaller-magnitude operand. \\ \hline
		\texttt{add\_path}     & Output & 1 & High when the magnitudes should be added; low for subtraction. \\ \hline
	\end{tabular}
\end{table}

\subsection{Datapath}

The datapath implementation is illustrated in
Figure~\textcolor{blue}{\ref{fig:sign_comp_datapath}}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{sign_computation.png}
	\caption{Sign Computation Datapath}
	\label{fig:sign_comp_datapath}
\end{figure}

The block is fully combinational and consists of:
\begin{itemize}
	\item two 2:1 multiplexers that route \texttt{sign\_a} and \texttt{sign\_b\_eff}
	to \texttt{sign\_big} and \texttt{sign\_small} according to \texttt{a\_is\_big};
	\item a 2-input XOR gate that compares \texttt{sign\_a} and \texttt{sign\_b\_eff};
	\item an inverter that generates \texttt{add\_path} from the XOR output.
\end{itemize}

\subsection{Functional Explanation}

The Sign Computation block operates as follows:
\begin{enumerate}
	\item The flag \texttt{a\_is\_big} selects which operand is treated as the
	larger-magnitude operand. The two 2:1 multiplexers assign the
	corresponding sign bits to \texttt{sign\_big} and \texttt{sign\_small}.
	\item The XOR gate computes the parity of \texttt{sign\_a} and \texttt{sign\_b\_eff}.
	If the signs differ, the XOR output is high; if they are equal, it is low.
	\item The inverter produces \texttt{add\_path}: it is high when the signs are
	equal (magnitude addition) and low when the signs differ (magnitude subtraction).
\end{enumerate}

In this way, the block cleanly separates sign handling from the magnitude datapath,
providing both the reordered operand signs and the add/sub control for the significand
adder.


%===================================
\section{Significand Add/Subtract}

The \texttt{fpu\_sig\_add\_sub} block performs the core magnitude operation on the
aligned significands. It adds or subtracts the 27-bit mantissas of the larger and
smaller operands and produces a raw 27-bit result together with a carry-out flag
for the normalization stage.

\subsection{Interface Specification}

This module receives the aligned mantissas from the Swap Operation and Alignment
Shift Right blocks, and the \texttt{add\_path} control from the Sign Computation
block. Its outputs feed directly into the normalization logic.
The interface signals are summarized in Table~\ref{tab:sig_add_sub_io}.

\begin{table}[H]
	\centering
	\caption{Significand Add/Subtract Module I/O Signals}
	\label{tab:sig_add_sub_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{mant\_big}   & Input  & 27 & Mantissa of the larger-magnitude operand (aligned). \\ \hline
		\texttt{mant\_small} & Input  & 27 & Mantissa of the smaller-magnitude operand (aligned, possibly shifted). \\ \hline
		\texttt{add\_path}   & Input  & 1  & Operation select: 1 for addition, 0 for subtraction. \\ \hline
		\texttt{mant\_res}   & Output & 27 & Raw mantissa result after add/sub operation. \\ \hline
		\texttt{carry\_out}  & Output & 1  & Carry-out (for addition) or borrow information for normalization. \\ \hline
	\end{tabular}
\end{table}

\subsection{Datapath}

The datapath implementation is illustrated in
Figure~\textcolor{blue}{\ref{fig:sig_add_sub_datapath}}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{sign_add_sub.png}
	\caption{Significand Add/Subtract Datapath}
	\label{fig:sig_add_sub_datapath}
\end{figure}

Internally, the block is fully combinational and built from:
\begin{itemize}
	\item one dedicated 27-bit ripple adder that computes
	\texttt{mant\_big + mant\_small};
	\item one 27-bit subtractor path that computes
	\texttt{mant\_big - mant\_small};
	\item a 2:1 multiplexer for the mantissa result, selecting between
	the sum and difference;
	\item a 2:1 multiplexer for the carry/borrow flag, selecting the
	corresponding \texttt{carry\_out}.
\end{itemize}

\subsection{Functional Explanation}

The Significand Add/Subtract block operates as follows:
\begin{enumerate}
	\item The aligned mantissas \texttt{mant\_big} and \texttt{mant\_small}
	are applied in parallel to the adder and subtractor datapaths,
	producing \texttt{sum\_add} and \texttt{diff\_sub} together with
	their respective carry/borrow flags.
	\item The control signal \texttt{add\_path} selects which operation is
	active: when \texttt{add\_path = 1}, the adder outputs are chosen;
	when \texttt{add\_path = 0}, the subtractor outputs are chosen.
	\item The selected 27-bit result is driven on \texttt{mant\_res}, and
	the corresponding carry/borrow flag is driven on \texttt{carry\_out}
	for use in the subsequent normalization and exponent-adjustment logic.
\end{enumerate}

By isolating the magnitude arithmetic in this block and controlling it with
\texttt{add\_path}, the design cleanly separates sign handling from the
significand datapath while keeping the hardware structure simple and regular.


% =============================
\section{Normalization}

The \texttt{fpu\_normalization} block normalizes the raw mantissa/exponent pair produced
by the significand adder/subtractor. It handles the special overflow case of addition with
carry, general left-normalization after cancellation, and generates the final exponent,
fraction field, and status flags (overflow, underflow, zero).

\subsection{Interface Specification}

This module receives the post-add/sub mantissa (including GRS bits), the tentative exponent,
and control information from the Significand Add/Subtract block. It outputs the normalized
exponent and fraction to the pack stage, together with IEEE-style status flags.
The interface signals are summarized in Table~\textcolor{red}{\ref{tab:norm_io}}.

\begin{table}[H]
	\centering
	\caption{Normalization Module I/O Signals}
	\label{tab:norm_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{is\_add\_path} & Input  & 1  & High when the significand datapath performed addition (not subtraction). \\ \hline
		\texttt{carry\_in}     & Input  & 1  & Carry-out from the adder path; used to detect overflow add. \\ \hline
		\texttt{mant\_in}      & Input  & 27 & Raw mantissa result including hidden bit and GRS bits. \\ \hline
		\texttt{exp\_in}       & Input  & 8  & Tentative exponent associated with \texttt{mant\_in}. \\ \hline
		\texttt{exp\_out}      & Output & 8  & Normalized (and possibly saturated) exponent field. \\ \hline
		\texttt{frac\_out}     & Output & 23 & Normalized fraction field to be packed into IEEE~754 format. \\ \hline
		\texttt{overflow}      & Output & 1  & High when the result overflows and is saturated to $+\infty$. \\ \hline
		\texttt{underflow}     & Output & 1  & High when the result underflows into the subnormal/zero region. \\ \hline
		\texttt{is\_zero}      & Output & 1  & High when the final result is exactly zero (including cancellation). \\ \hline
	\end{tabular}
\end{table}

\subsection{Datapath}

The datapath is illustrated in Figure~\textcolor{blue}{\ref{fig:norm_datapath}}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{normalization.png}
	\caption{Normalization Datapath}
	\label{fig:norm_datapath}
\end{figure}

The \texttt{fpu\_normalization} block is a purely combinational circuit designed to restore the IEEE-754 standard format through two parallel processing paths:

\begin{itemize}
	\item \textbf{Path A (Overflow Handling):} Activated during addition overflow (carry-out). It performs a 1-bit right shift, increments the exponent, and applies round-to-nearest-even logic using the extracted GRS bits.
	\item \textbf{Path B (Standard Normalization):} Utilizes a Leading Zero Counter (LZC) and a Barrel Shifter to left-shift the mantissa until the MSB is '1'. Simultaneously, the shift amount is subtracted from the exponent to detect potential underflow conditions.
	\item \textbf{Output Generation:} A multiplexer selects the valid path based on the operation context. The block finalizes the 32-bit result by handling special cases (forcing Infinity/Zero) and asserting the corresponding status flags (Overflow, Underflow, Zero).
\end{itemize}


\subsection{Functional Explanation}

The Normalization block processes the intermediate arithmetic result through the following steps:

\begin{enumerate}
	\item \textbf{Path Selection:} The control logic determines whether to process an overflow from addition (right-shift path) or normalize a standard result (left-shift path) based on the carry-out signal.
	
	\item \textbf{Overflow Processing:} If an addition overflow occurs, the mantissa is right-shifted by one bit, and the exponent is incremented. Rounding logic is applied using the GRS bits to ensure precision. If the exponent reaches the maximum limit, the result is saturated to Infinity.
	
	\item \textbf{Standard Normalization:} For other cases, the Leading Zero Counter (LZC) identifies the position of the most significant '1'. The Barrel Shifter left-shifts the mantissa to restore the $1.M$ format, while the exponent is decremented accordingly. Underflow is detected if the exponent drops below the minimum representable value.
	
	\item \textbf{Final Output Logic:} The block selects the valid result from the active path. It then performs a final check for special conditions—forcing the output to Zero in cases of underflow or cancellation, and to Infinity in cases of overflow—before driving the final \texttt{exp\_out}, \texttt{frac\_out}, and status flags.
\end{enumerate}

This streamlined process ensures that the result is compliant with IEEE-754 standards regarding normalization, rounding, and exception handling before final packing.

%=======================
\section{Special Case Handling}

The \texttt{fpu\_special\_case} block detects IEEE~754 special cases on the operands
(NaN, infinity, and zero) and, when applicable, bypasses the main adder/subtractor
datapath. For such operations, it directly returns a pre-encoded 32-bit result and
asserts a valid flag so that later stages ignore the normal pipeline outputs.

\subsection{Interface Specification}

This module receives the decomposed operand fields and classification flags from the
Unpack \& Pretest block. When a special condition is detected, it produces the final
floating-point result along with a \texttt{special\_valid} indication. The interface
is summarized in Table~\textcolor{red}{\ref{tab:special_case_io}}.

\begin{table}[H]
	\centering
	\caption{Special Case Handling Module I/O Signals}
	\label{tab:special_case_io}
	\begin{tabular}{|l|c|c|p{6.0cm}|}
		\hline
		\textbf{Signal} & \textbf{Dir.} & \textbf{Width} & \textbf{Description} \\ \hline
		\texttt{sign\_a}       & Input  & 1  & Sign bit of operand~A. \\ \hline
		\texttt{sign\_b\_eff}  & Input  & 1  & Effective sign bit of operand~B after add/sub control. \\ \hline
		\texttt{exp\_a}, \texttt{exp\_b}   & Input  & 8  & Exponent fields of operands A and B. \\ \hline
		\texttt{frac\_a}, \texttt{frac\_b} & Input  & 23 & Fraction fields of operands A and B. \\ \hline
		\texttt{is\_zero\_a}, \texttt{is\_zero\_b} & Input & 1 & Classification flags: operand A/B is zero. \\ \hline
		\texttt{is\_inf\_a}, \texttt{is\_inf\_b}   & Input & 1 & Classification flags: operand A/B is infinity. \\ \hline
		\texttt{is\_nan\_a}, \texttt{is\_nan\_b}   & Input & 1 & Classification flags: operand A/B is NaN. \\ \hline
		\texttt{special\_valid} & Output & 1  & High when the operation hits a special case and the normal datapath must be bypassed. \\ \hline
		\texttt{special\_res}   & Output & 32 & Pre-encoded IEEE~754 result for NaN/Inf/zero cases. \\ \hline
	\end{tabular}
\end{table}

\subsection{Datapath}

The datapath implementation is illustrated in
Figure~\textcolor{blue}{\ref{fig:special_case_datapath}}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{special_case.png}
	\caption{Special Case Handling Datapath}
	\label{fig:special_case_datapath}
\end{figure}

Internally, the block is fully combinational and organized into three parts:
\begin{itemize}
	\item \textbf{Condition generation:}  
	Combinational logic combines the input classification flags and signs to
	form case-specific conditions such as ``any NaN present'', ``Inf~$\pm$~Inf'',
	``finite~$\pm$~Inf'', and ``both operands zero''.
	\item \textbf{Priority selection:}  
	A simple priority encoder determines which special case (NaN, infinity, zero, etc.)
	takes precedence when multiple conditions are true, following IEEE~754 rules
	(NaN has highest priority).
	\item \textbf{Result encoding:}  
	A small result multiplexer selects one of several pre-encoded 32-bit patterns
	(canonical quiet NaN, signed infinity, signed zero, etc.), drives it to
	\texttt{special\_res}, and asserts \texttt{special\_valid}.
\end{itemize}

\subsection{Functional Explanation}

The Special Case Handling block operates as follows:
\begin{enumerate}
	\item Using \texttt{is\_nan\_*}, \texttt{is\_inf\_*}, and \texttt{is\_zero\_*}, it
	detects if either operand is NaN, infinity, or zero, and identifies compound
	cases such as NaN involvement or $\infty - \infty$.
	\item A priority network selects the dominant case:
	\begin{itemize}
		\item any NaN (or invalid operation) $\rightarrow$ canonical quiet NaN;
		\item one or both infinities $\rightarrow$ signed infinity result
		(sign derived from \texttt{sign\_a} / \texttt{sign\_b\_eff});
		\item both operands zero $\rightarrow$ signed zero result.
	\end{itemize}
	\item For the selected case, a fixed 32-bit IEEE~754 code word is generated on
	\texttt{special\_res} and \texttt{special\_valid} is asserted to tell the
	downstream stages to ignore the normal add/sub/normalize result.
	\item If no special condition is active, \texttt{special\_valid} remains low and
	\texttt{special\_res} is ignored; the main FPU datapath then produces the
	final result.
\end{enumerate}

This block therefore localizes all NaN/Inf/zero handling and keeps the main arithmetic
datapath focused on normalized finite operands.



% ==========================================================
\chapter{VERIFICATION STRATEGY}

In order to gain confidence in the correctness of the design, a structured
verification flow was adopted. The RTL core was first verified at the
behavioural level using a self-checking SystemVerilog testbench with
both directed and constrained-random stimuli. Corner cases were chosen
to exercise all special conditions (±0, subnormal numbers, overflow,
underflow, infinities and NaNs), while random tests targeted typical
operating ranges. \\

After functional verification, the synthesized netlist was validated with
SDF back-annotation to confirm that timing did not introduce any
functional issues. Finally, a reduced but representative set of test
scenarios was executed on the DE2 FPGA board to demonstrate correct
operation in real hardware.

\section{Testbench Analysis \& Results}

In order to validate the functionality and numerical accuracy of the 32-bit floating-point adder/subtractor, a self-checking SystemVerilog testbench is implemented, can view on Listing~\textcolor{orange}{\ref{app:fpu_testbench}}. The testbench not only provides a set of directed test cases for important corner conditions (zero, overflow, underflow, infinities, and NaNs), but also generates constrained-random operands to stress the datapath under more realistic scenarios. \\

For each input vector, the testbench computes a reference result using the simulator’s floating-point arithmetic, applies the same flush-to-zero policy as the hardware, and automatically compares the expected value with the DUT output. \\


The testbench executes 100 test vectors and reports detailed per-case results along with summary statistics. Figure~\textcolor{blue}{\ref{fig:testbench_results}}, ~\textcolor{blue}{\ref{fig:testbench_results_2}} and ~\textcolor{blue}{\ref{fig:testbench_results_3}} shows the simulation log, demonstrating successful verification across all test scenarios. \\



\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{pass1.png}
	\caption{Special Cases \& Overflow Scenarios (Cases 1-33)}
	\label{fig:testbench_results}
\end{figure}

This log captures the initial phase of the testbench, covering Manual Corner Cases (1–6) and the Force Overflow Loop (7–33). \\

The FPU correctly identifies and processes IEEE-754 special values, including Signed Zeros ($\pm 0$), Infinities ($\pm \infty$), and Not-a-Number (NaN). Notably, Case 6 ($\infty - \infty$) correctly results in 0xFFC00000 (Quiet NaN) with no arithmetic flags raised, complying with standard exception handling. \\

From Case 7 onwards, the generator forces inputs with maximum exponents. The FPU consistently detects the overflow condition, saturates the result to Infinity (0x7F800000 or 0xFF800000), and asserts the Overflow (OV) flag.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{pass2.png}
	\caption{Underflow Scenarios \& Flush-to-Zero (Cases 34-73).}
		\label{fig:testbench_results_2}
\end{figure}

This section highlights the Force Underflow Loop (Cases 34–73), where the system is stressed with extremely small operands. \\


The log demonstrates the successful implementation of the Flush-to-Zero mode. In operations where the result falls into the subnormal range (e.g., Case 42, 43), the FPU forces the magnitude to zero instead of calculating a denormalized value. \\

Crucially, the design maintains the correct sign even when the value is flushed to zero. For example, Case 43 results in 0x80000000 (Negative Zero), proving that the Sign Logic operates correctly independent of the Underflow Detection logic. \\

The Underflow (UN) flag is consistently triggered in these scenarios, validating the detection logic for minimum exponent violations.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{pass3.png}
	\caption{Normal Random Cases \& Final Summary (Cases 74-100).}
		\label{fig:testbench_results_3}
\end{figure}

The final phase covers Normal Random Cases (74–100) and presents the Final Simulation Statistics. The "Normal Random" cases verify that the FPU performs standard addition and subtraction correctly for typical floating-point numbers without triggering exceptions. \\

As shown in the simulation log, all 100 test cases passed successfully (PASS: 100, FAIL: 0). The flag statistics indicate that the design correctly detected 2 overflow conditions, 35 underflow conditions, and 2 zero results. The directed test cases successfully exercised critical corner cases including zero subtraction (test 1), maximum value overflow (tests 2-3), minimum value underflow (test 4), infinity operations (tests 5-6), and the randomized tests verified normal operation ranges. The constrained-random approach with different generator modes (FORCE OVERFLOW, FORCE UNDERFLOW, NORMAL RANDOM) ensured comprehensive coverage of the floating-point datapath under various numerical conditions.


\section{Waveform Analysis}

To validate the functional correctness of the FPU RTL design, simulation waveforms were captured for five critical scenarios. These cases cover the full spectrum of IEEE-754 operations, ranging from standard arithmetic to complex exception handling.

% --- CASE 1: STANDARD ARITHMETIC ---
\subsection{Standard Arithmetic Validation}
\label{subsec:standard_arithmetic}

%\begin{figure}[H]
%	\centering
	% Thay tên file ảnh của bạn vào đây (ví dụ: wave_normal_add.png)
%	\includegraphics[width=1\textwidth]{placeholder_normal_case.png}
%	\caption{Standard Addition: $16.0 + 20.25 = 36.25$}
%	\label{fig:normal_arithmetic}
%\end{figure}


This test case verifies the FPU's ability to perform standard arithmetic operations on normalized numbers without triggering exceptions.
\begin{itemize}
	\item \textbf{Operation:} Addition of $16.0$ (\texttt{0x41800000}) and $20.25$ (\texttt{0x41A20000}).
	\item \textbf{Observation:} The output \texttt{o\_z} correctly resolves to \texttt{0x42110000} ($36.25$). The exponent alignment and mantissa addition logic function correctly.
	\item \textbf{Flags:} All exception flags (Overflow, Underflow, Zero) remain de-asserted, confirming a valid normal operation.
\end{itemize}

% --- CASE 2: OVERFLOW ---
\subsection{Overflow Detection (Saturation to Infinity)}
\label{subsec:overflow_detection}

%\begin{figure}[H]
%	\centering
	% Thay tên file ảnh của bạn vào đây
%	\includegraphics[width=1\textwidth]{placeholder_overflow.png}
%	\caption{Overflow detection resulting in Positive Infinity}
%	\label{fig:overflow_case}
%\end{figure}


This scenario validates the saturation logic when the result exceeds the maximum representable value in single-precision format ($\approx 3.4 \times 10^{38}$).
\begin{itemize}
	\item \textbf{Operation:} Addition of two maximum positive values (\texttt{0x7F7FFFFF}).
	\item \textbf{Observation:} The result saturates to Positive Infinity (\texttt{0x7F800000}).
	\item \textbf{Flags:} The \textbf{Overflow (OV)} flag asserts HIGH, correctly signaling the range violation.
\end{itemize}

% --- CASE 3: UNDERFLOW (Dùng lại nội dung bạn gửi) ---
\subsection{Detection of Minimum Normal Subtraction Resulting in Zero}
\label{subsec:min_normal_subtraction}

\begin{figure}[H]
	\centering
% Thay tên file ảnh của bạn vào đây
	\includegraphics[width=1\textwidth]{min_normal_subtraction_waveform.png}
	\caption{Underflow detection and flush-to-zero for minimum normal subtraction}
	\label{fig:min_normal_subtraction}
\end{figure}

The FPU correctly handles extreme underflow conditions when subtracting minimum normal numbers (\texttt{0x00800001 - 0x00800000}) by implementing flush-to-zero behavior. The mathematical result, while theoretically non-zero, falls below the representable range of subnormal numbers, triggering both Underflow and Zero flags. This demonstrates proper detection of precision loss scenarios where results cannot be represented even in denormalized form, ensuring IEEE-754 compliant behavior for arithmetic operations at the numerical limits of the floating-point format.

% --- CASE 4: NAN (Dùng lại nội dung bạn gửi) ---
\subsection{Handling of Indeterminate Forms $\infty - \infty$}
\label{subsec:inf_minus_inf}

\begin{figure}[H]
	\centering
	% Thay tên file ảnh của bạn vào đây
	\includegraphics[width=1\textwidth]{inf_minus_inf_waveform.png}
	\caption{$\infty - \infty$ test case waveform showing proper NaN generation}
	\label{fig:inf_minus_inf_waveform}
\end{figure}

The FPU correctly handles the IEEE-754 indeterminate form $\infty - \infty$ by generating a Quiet NaN (\texttt{0x7FC00000}) while keeping all status flags inactive. This test case, using two positive infinity inputs (\texttt{0x7F800000}) in subtraction mode, validates that the design properly categorizes this scenario as an invalid operation exception rather than a numerical overflow or underflow condition. The resulting NaN output with exponent field \texttt{0xFF} and non-zero mantissa confirms standard-compliant behavior for this edge case.

% --- CASE 5: NEGATIVE ZERO ---
\subsection{Signed Zero Preservation}
\label{subsec:signed_zero}

%\begin{figure}[H]
%	\centering
	% Thay tên file ảnh của bạn vào đây
%	\includegraphics[width=1\textwidth]{placeholder_neg_zero.png}
%	\caption{Verification of Negative Zero (-0) handling}
%	\label{fig:neg_zero_case}
%\end{figure}

This case confirms that the sign bit calculation is independent of the magnitude normalization path.
\begin{itemize}
	\item \textbf{Operation:} Subtraction where the negative operand has a slightly larger magnitude than the positive operand, resulting in an underflow.
	\item \textbf{Observation:} The magnitude is flushed to zero due to underflow, but the \textbf{Sign bit remains 1} (Negative). The final result is \texttt{0x80000000} (Negative Zero).
	\item \textbf{Conclusion:} This proves the FPU strictly adheres to IEEE-754 signed-zero rules, which is critical for subsequent operations such as $1/(-0) = -\infty$.
\end{itemize}


\subsection{Verification Summary}

Table~\textcolor{red}{\ref{tab:sim_summary}} provides a consolidated view of the critical test scenarios executed during the RTL simulation phase.

\begin{table}[H]
	\centering
		{\fontsize{10pt}{13.5pt}\selectfont
	\caption{RTL Simulation Results Summary}
	\label{tab:sim_summary}
	\renewcommand{\arraystretch}{1.3}
	\setlength{\tabcolsep}{8pt}
	\rowcolors{2}{blue!10}{white}
	
	\begin{tabular}{ c p{4.5cm} p{5.5cm} c }
		\toprule
		\textbf{Case} & \textbf{Test Scenario} & \textbf{Practical Behavior \& Flags} & \textbf{Status} \\ 
		\midrule
		
		\textbf{1} & 
		\textbf{Standard Arithmetic} \newline
		Addition of normal numbers. & 
		Matches IEEE-754 standard. \newline
		Flags: \texttt{All Low}. & 
		\textbf{\textcolor{teal}{PASS}} \\ 
		\arrayrulecolor{gray!30}\hline
		
		\textbf{2} & 
		\textbf{Overflow Detection} \newline
		Result $> 3.4 \times 10^{38}$. & 
		Saturation to Infinity ($\pm \infty$). \newline
		Flags: \texttt{OV=1}. & 
		\textbf{\textcolor{teal}{PASS}} \\ 
		\hline
		
		\textbf{3} & 
		\textbf{Underflow Handling} \newline
		Result $< 1.17 \times 10^{-38}$. & 
		Flush-to-Zero mechanism. \newline
		Flags: \texttt{UN=1}, \texttt{ZE=1}. & 
		\textbf{\textcolor{teal}{PASS}} \\ 
		\hline
		
		\textbf{4} & 
		\textbf{Invalid Operation} \newline
		$\infty - \infty$  & 
		Result transitions to NaN. \newline
		Flags: \texttt{All Low} (Exception). & 
		\textbf{\textcolor{teal}{PASS}} \\ 
		\hline
		
		\textbf{5} & 
		\textbf{Signed Zero} \newline
		Underflow with negative sign. & 
		Result is Negative Zero (\texttt{-0}). \newline
		Sign bit preserved. & 
		\textbf{\textcolor{teal}{PASS}} \\ 
		
		\bottomrule
	\end{tabular}
}
\end{table}

The RTL simulation confirms that the FPU design is functionally correct and fully compliant with the IEEE-754 single-precision standard. All critical paths, including arithmetic logic, normalization shifts, and special case detection, operate as intended across the tested vectors.



\chapter{FPGA IMPLEMENTATIONS}

\section{Input/Output Mapping Strategy}

Due to the inherent limitation of physical I/O pins on the DE2 board, a direct mapping is impossible. To overcome this, a \textit{Smart Wrapper} architecture was developed. This architecture employs a \textbf{Mode Selection} mechanism using the two most significant switches (\texttt{SW[17:16]}) to dynamically switch between manual input operation and pre-defined corner case verification.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{de2.png}
	\caption{Physical I/O Mapping Configuration on the Altera DE2.}
	\label{fig:wrapper_diagram}
\end{figure}

\subsection{Operand Construction \& Mode Selection}

The input logic is governed by a 4-to-1 Multiplexer controlled by \texttt{SW[17:16]}. This allows the system to operate in four distinct modes:

\subsubsection{Normal Operation Mode (\texttt{SW[17:16] = 00})}

In this mode, Operand \textbf{B} is fixed to a reference constant to test alignment logic, while Operand \textbf{A} is manually constructed to test magnitude calculation.

\begin{itemize}
	\item \textbf{Operand B (Fixed):} $20.25_{10}$ (\texttt{32'h41A20000}).
	\item \textbf{Operand A (Manual):} Constructed to ensure comparable magnitude with B:
	\begin{itemize}
		\item \textbf{Sign:} Controlled by \texttt{SW[8]}.
		\item \textbf{Exponent:} The 4 MSBs are hard-wired to \texttt{1000} ($8_{10}$) to match the magnitude order of B ($2^4$). The 4 LSBs are controlled by \texttt{SW[7:4]}.
		\item \textbf{Mantissa:} The 4 MSBs are controlled by \texttt{SW[3:0]}, with the remaining bits padded to zero.
	\end{itemize}
\end{itemize}

\subsubsection{Forced Exception Modes (\texttt{SW[17:16] = 01, 10, 11})}

To validate status flags (Overflow, Underflow, Zero) which are difficult to trigger via manual switches due to precision limits, the wrapper automatically injects hard-coded 32-bit vectors when these modes are selected.

\begin{table}[h]
	\centering
	\caption{Input Mode Selection Truth Table}
	\begin{tabular}{|c|c|l|l|l|c|}
		\hline
		\textbf{Mode} & \textbf{SW[17:16]} & \textbf{Function} & \textbf{Operand A} & \textbf{Operand B} & \textbf{Operation} \\
		\hline
		Normal & \texttt{00} & Manual Entry & Manual (Switches) & $20.25$ & Manual (\texttt{SW[9]}) \\
		\hline
		Overflow & \texttt{01} & Force Overflow & Max Float & Max Float & ADD \\
		\hline
		Underflow & \texttt{10} & Force Underflow & Min Normal + 1 & Min Normal & SUB \\
		\hline
		Zero & \texttt{11} & Force Zero & $20.25$ & $20.25$ & SUB \\
		\hline
	\end{tabular}
	\label{tab:input_mode}
\end{table}

\subsection{Output Visualization}

The 32-bit floating-point result ($S$) and status flags are mapped to the LED interface. To maximize readability, the Red LEDs display the critical bits of the result, while the Green LEDs are dedicated to status flags.

\begin{table}[h]
	\centering
	\caption{Output Pin Mapping Configuration}
	\begin{tabular}{|l|l|l|p{6cm}|}
		\hline
		\textbf{Output Group} & \textbf{FPGA Pin} & \textbf{Signal Source} & \textbf{Description} \\
		\hline
		Mode Indicator & \texttt{LEDR[9]} & \texttt{i\_add\_sub} & Indicates the effective operation (0: Add, 1: Sub). \\
		\hline
		Sign Bit & \texttt{LEDR[8]} & $S[31]$ & Result Sign (ON = Negative). \\
		\hline
		Exponent & \texttt{LEDR[7:4]} & $S[26:23]$ & Displays the 4 LSBs of the Exponent. \\
		\hline
		Mantissa & \texttt{LEDR[3:0]} & $S[22:19]$ & Displays the 4 MSBs of the Mantissa. \\
		\hline
		\multirow{3}{*}{Status Flags} & \texttt{LEDG[2]} & Overflow & Active High. \\
		\cline{2-4}
		& \texttt{LEDG[1]} & Underflow & Active High. \\
		\cline{2-4}
		& \texttt{LEDG[0]} & Zero & Active High. \\
		\hline
	\end{tabular}
	\label{tab:output_mapping}
\end{table}


\section{Experimental Verification Results}

Five distinct test scenarios were executed to validate the FPU across its entire operational range, from standard arithmetic to critical exception handling.

\subsection{Scenario 1: Normal Addition}

\begin{itemize}
	\item \textbf{Configuration:} Normal Mode (\texttt{SW[17:16]=00}), ADD (\texttt{SW[9]=0}), Input A configured to $\approx 16.0$.
	\item \textbf{Operation:} $16.0 + 20.25 = 36.25$.
	\item \textbf{Observation:}
	\begin{itemize}
		\item \texttt{LEDR[8]} (Sign) is OFF (Positive).
		\item \texttt{LEDR[6]} and \texttt{LEDR[1]} are ON, correctly representing the bit pattern of $36.25$.
		\item All Green LEDs (Flags) are OFF.
	\end{itemize}
	\item \textbf{Result:} Validates the alignment and adder logic for same-sign operands.
\end{itemize}

\begin{figure}[H]
	\centering
	
	\fbox{\parbox{1\textwidth}{\centering \includegraphics[width=1\textwidth]{fpga_case1.jpg}}}
	\caption{Experimental result for Case 1 (Normal Addition).}
	\label{fig:case1}
\end{figure}

\subsection{Scenario 2: Subtraction yielding Negative Result}

\begin{itemize}
	\item \textbf{Configuration:} Normal Mode (\texttt{SW[17:16]=00}), SUB (\texttt{SW[9]=1}), Input A configured to $\approx 16.0$.
	\item \textbf{Operation:} $16.0 - 20.25 = -4.25$.
	\item \textbf{Observation:}
	\begin{itemize}
		\item \textbf{\texttt{LEDR[9]} (Mode)} is ON.
		\item \textbf{\texttt{LEDR[8]} (Sign)} is \textbf{ON}, correctly indicating a negative result.
		\item \texttt{LEDR[0]} and \texttt{LEDR[4]} are ON, matching the pattern for $-4.25$.
	\end{itemize}
	\item \textbf{Result:} Validates the 2's complement logic and sign determination block.
\end{itemize}

\begin{figure}[H]
	\centering
	\fbox{\parbox{1\textwidth}{\centering \includegraphics[width=1\textwidth]{fpga_case2.jpg}}}
	\caption{Experimental result for Case 2 (Subtraction), showing the Negative Sign LED active.}
	\label{fig:case2}
\end{figure}

\subsection{Scenario 3: Overflow Detection}

\begin{itemize}
	\item \textbf{Configuration:} Overflow Mode (\texttt{SW[17:16]=01}).
	\item \textbf{Operation:} Injects \texttt{Max\_Float + Max\_Float}.
	\item \textbf{Observation:}
	\begin{itemize}
		\item \textbf{\texttt{LEDG[2]} (Overflow)} turns ON.
		\item \texttt{LEDR[7:4]} all turn ON (Exp = 255).
	\end{itemize}
	\item \textbf{Result:} Validates overflow detection when the result exceeds the maximum representable value.
\end{itemize}

\begin{figure}[H]
	\centering
	
		\fbox{\parbox{1\textwidth}{\centering \includegraphics[width=1\textwidth]{fpga_case3.jpg}}}
	\caption{Experimental result for Case 3 (Overflow), showing LEDG[2] asserted.}
	\label{fig:case3}
\end{figure}

\subsection{Scenario 4: Underflow Detection \& Flush-to-Zero}

\begin{itemize}
	\item \textbf{Configuration:} Underflow Mode (\texttt{SW[17:16]=10}).
	\item \textbf{Operation:} Injects \texttt{(Min Normal + 1) - Min Normal}.
	\item \textbf{Observation:}
	\begin{itemize}
		\item \textbf{\texttt{LEDG[1]} (Underflow)} turns ON.
	\item	\textbf{\texttt{LEDG[0]} (Zero)}: ON. This confirms that the result was flushed to zero.
		\item All Data LEDs turn OFF (confirming the magnitude is zero).
	\end{itemize}
	\item \textbf{Result:} The simultaneous assertion of both Underflow and Zero flags validates the \textit{Flush-to-Zero} mechanism, accurately reporting both the exception event and the final value state.
\end{itemize}

\begin{figure}[H]
	\centering
	\fbox{\parbox{1\textwidth}{\centering \includegraphics[width=1\textwidth]{fpga_case4.jpg}}}
	\caption{Experimental result for Case 4 (Underflow), showing LEDG[1] asserted.}
	\label{fig:case4}
\end{figure}

\subsection{Scenario 5: Zero Cancellation}

\begin{itemize}
	\item \textbf{Configuration:} Zero Mode (\texttt{SW[17:16]=11}).
	\item \textbf{Operation:} Injects \texttt{20.25 - 20.25}.
	\item \textbf{Observation:}
	\begin{itemize}
		\item \textbf{\texttt{LEDG[0]} (Zero)} turns ON.
		\item All Data LEDs turn OFF.
	\end{itemize}
	\item \textbf{Result:} Validates zero detection for exact cancellation scenarios.
\end{itemize}

\begin{figure}[H]
	\centering
	\fbox{\parbox{1\textwidth}{\centering \includegraphics[width=1\textwidth]{fpga_case5.jpg}}}
	\caption{Experimental result for Case 5 (Zero Cancellation), showing LEDG[0] asserted.}
	\label{fig:case5}
\end{figure}






\section{FPGA Verification Summary}

To overcome the physical I/O constraints of the DE2 board, the verification strategy employed a hybrid approach: standard arithmetic and forced injection for corner cases. This allowed for a comprehensive hardware validation of all critical FPU features.

\begin{table}[H]
	\centering
	{\fontsize{10pt}{13.5pt}\selectfont
	\caption{Summary of FPGA Hardware Verification Results}
	\label{tab:fpga_summary}
	\renewcommand{\arraystretch}{1.4} % Tăng chiều cao dòng cho thoáng
	\setlength{\tabcolsep}{10pt}      % Tăng khoảng cách cột
	
	% Định nghĩa màu cho hàng chẵn/lẻ (Zebra striping)
	% Nếu latex báo lỗi rowcolors thì bỏ dòng này đi
	\rowcolors{2}{teal!10}{white}
	
	\begin{tabular}{ c p{5cm} p{5cm} c }
		\toprule
		\textbf{Case} & \textbf{Scenario \& Configuration} & \textbf{ Observation} & \textbf{Result} \\ 
		\midrule
		
		\textbf{1} & 
		\textbf{Normal Addition} \newline
		$16.0 + 20.25 = 36.25$ \newline
		{\footnotesize \textit{Mode: Manual (SW[17:16]=00)}} & 
		LEDR display: \texttt{LEDR[6] \& LEDR[1]}: \textbf{ON}  \newline
		Correct magnitude pattern. & 
		\textbf{\textcolor{blue}{PASS}} \\ 
		
		\textbf{2} & 
		\textbf{Subtraction (Negative)} \newline
		$16.0 - 20.25 = -4.25$ \newline
		{\footnotesize \textit{Mode: Manual (SW[17:16]=00)}} & 
		Sign LED (\texttt{LEDR[8]}): \textbf{ON}. \newline
		Correct negative result. & 
		\textbf{\textcolor{blue}{PASS}} \\ 
		
		\textbf{3} & 
		\textbf{Overflow Detection} \newline
		Max + Max $\rightarrow \infty$ \newline
		{\footnotesize \textit{Mode: Forced (SW[17:16]=01)}} & 
		Overflow Flag (\texttt{LEDG[2]}): \textbf{ON}. \newline
		Result saturates to Infinity. & 
		\textbf{\textcolor{blue}{PASS}} \\ 
		
		\textbf{4} & 
		\textbf{Underflow \& Flush-to-Zero} \newline
		Min - Min $\rightarrow 0$ \newline
		{\footnotesize \textit{Mode: Forced (SW[17:16]=10)}} & 
		Underflow Flag (\texttt{LEDG[1]}): \textbf{ON}. \newline
		Zero Flag (\texttt{LEDG[0]}): \textbf{ON}. & 
		\textbf{\textcolor{blue}{PASS}} \\ 
		
		\textbf{5} & 
		\textbf{Exact Zero Cancellation} \newline
		$20.25 - 20.25 = 0$ \newline
		{\footnotesize \textit{Mode: Forced (SW[17:16]=11)}} & 
		Zero Flag (\texttt{LEDG[0]}): \textbf{ON}. \newline
		Data LEDs: All OFF. & 
		\textbf{\textcolor{blue}{PASS}} \\ 
		
		\bottomrule
	\end{tabular}
}
\end{table}

The FPGA implementation has successfully demonstrated the core functionality of the designed.
\begin{itemize}
	\item The \textbf{Arithmetic Logic} correctly handles magnitude alignment and 2's complement operations.
	\item The \textbf{Exception Handling Logic} accurately detects and reports Overflow, Underflow, and Zero conditions.
	\item The \textbf{Flush-to-Zero} mechanism operates correctly in hardware.
\end{itemize}
By utilizing the Mode Selection technique, we have effectively bypassed the limitation of input switches, achieving 100\% coverage of the defined hardware test plan.











\chapter{SYNTHESIS \& OPTIMIZATION}
\section{Physical Analysis}

\subsection{Overall Netlist Transformation}
The synthesis process transforms the behavioral RTL into a structural gate-level netlist.


\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{schematic_generic.png}
	\caption{Generic Gate-level Schematic (Pre-mapping).}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{schematic_mapped.png}
	\caption{Technology-mapped Netlist (Post-mapping) using 45nm Standard Cells.}
\end{figure}


\subsection{Corner Netlist (Post-Optimization)}


\subsubsection{Corner 1: \texttt{fast\_vdd1v0\_basicCells\_hvt}}

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{corner1_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Fast-Corner Constraints.}
\end{figure}

\subsubsection{Corner 2: \texttt{fast\_vdd1v0\_basicCells\_lvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{corner2_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Fast-Corner Constraints.}
\end{figure}

\subsubsection{Corner 3: \texttt{fast\_vdd1v2\_basicCells\_hvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner3_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Fast-Corner Constraints.}
	\label{fig:overflow_wave}
\end{figure}


\subsection{Corner 4: \texttt{fast\_vdd1v2\_basicCells\_lvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner4_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Fast-Corner Constraints.}
	\label{fig:overflow_wave}
\end{figure}


The schematics for Corners 1 through 4 (Fast Process, 1.0V/1.2V) display the topology after technology mapping. In these corners, transistor switching is extremely fast. \\

Although visually dense, the synthesis tool prioritizes Hold-Time Closure here. You would likely find a higher number of buffers or delay elements inserted on short paths (datapath) to prevent race conditions. The tool typically selects smaller drive-strength cells (e.g., X1) to save area and dynamic power, as Setup Time is easily met.

\subsubsection{Corner 5: \texttt{slow\_vdd1v0\_basicCells\_hvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner5_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Slow-Corner Constraints (Setup-Time Driven).}
	\label{fig:overflow_wave}
\end{figure}

This schematic provides a modular view of the synthesized design, clearly distinguishing the fpu\_unpack module from the arithmetic core. \\

This corresponds to Corner 5 (slow\_vdd1v0\_hvt), which is the worst-case timing scenario (lowest voltage, high threshold). Showing the hierarchy here verifies that even under extreme timing pressure, the synthesis tool preserved the module boundaries for the Unpacking stage, ensuring clean interfaces before the signal enters the flattened optimization logic of the critical path."




\subsubsection{Corner 6: \texttt{slow\_vdd1v0\_basicCells\_lvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner6_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Slow-Corner Constraints (Setup-Time Driven).}
	\label{fig:overflow_wave}
\end{figure}


\subsubsection{Corner 7: \texttt{slow\_vdd1v2\_basicCells\_hvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner7_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Slow-Corner Constraints (Setup-Time Driven).}
	\label{fig:overflow_wave}
\end{figure}



\subsubsection{Corner 8: \texttt{slow\_vdd1v2\_basicCells\_lvt}}



\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{corner8_schematic_mapped.jpg}
	\caption{Synthesized Netlist under Slow-Corner Constraints (Setup-Time Driven).}
	\label{fig:overflow_wave}
\end{figure}

These netlists correspond to the Slow process corners. To combat the degraded transistor performance (slow switching), the synthesis tool restructures the logic cone for Setup-Time Closure. \\

Unlike the Fast corners, the tool here instantiates High-Drive Strength Cells (e.g., AND2\_X4, AOI\_X8) and uses Low-VT (LVT) variants aggressively to speed up the Critical Path. This results in a larger total cell area and higher leakage power consumption compared to the Fast corner implementation."


\subsection{Resource \& Power Usage}
Table \ref{tab:phys_metrics} summarizes the physical cost of the FPU across different Process, Voltage, and Temperature (PVT) corners. The results demonstrate the design's efficiency, with area usage hovering around $1700 \mu m^2$ and power consumption remaining extremely low suitable for low-power embedded applications.

\begin{table}[H]
	\centering
	\caption{Post-Synthesis Area \& Power Report across 8 PVT Corners}
	\label{tab:phys_metrics}
	\renewcommand{\arraystretch}{1.2} % Tăng giãn dòng cho dễ đọc
	\setlength{\tabcolsep}{8pt}       % Tăng khoảng cách cột
	\begin{tabular}{lcccc}
		\toprule
		\textbf{Corner ID} & \textbf{Area} & \textbf{Leakage} & \textbf{Dynamic} & \textbf{Total Power} \\
		\textit{(PVT Condition)} & ($\mu m^2$) & ($nW$) & ($\mu W$) & ($\mu W$) \\
		\midrule
		slow\_vdd1v0\_hvt & 1720.94 & 24.36 & 51.18 & \textbf{51.21} \\
		slow\_vdd1v0\_lvt & 1673.41 & 150.91 & 56.26 & 56.41 \\
		slow\_vdd1v2\_hvt & 1677.51 & 43.94 & 74.93 & 74.97 \\
		slow\_vdd1v2\_lvt & 1672.72 & 213.25 & 86.50 & 86.71 \\
		fast\_vdd1v0\_hvt & 1674.09 & 94.22 & 75.66 & 75.75 \\
		fast\_vdd1v0\_lvt & 1669.30 & 698.50 & 98.48 & 99.17 \\
		fast\_vdd1v2\_hvt & 1670.67 & 208.70 & 114.11 & 114.33 \\
		fast\_vdd1v2\_lvt & \textbf{1668.96} & \textbf{1019.78} & \textbf{155.18} & \textbf{156.20} \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}
	\\ \footnotesize{\textit{*Note: Bold values indicate the Lowest Total Power and the Highest Total Power cases.}}
\end{table}

As shown in Table \ref{tab:phys_metrics}, the \textbf{slow\_vdd1v0\_hvt} corner yields the lowest total power consumption ($51.21 \mu W$) due to the use of High-Vt cells and lower operating voltage. Conversely, the \textbf{fast\_vdd1v2\_lvt} corner represents the worst-case scenario for power ($156.20 \mu W$) and leakage ($1019.78 nW$) due to the high-performance Low-Vt cells and increased voltage. The area variation between corners is minimal ($\approx 3\%$), indicating a stable structural synthesis.


%=================================================================
\section{Baseline Design Analysis (Pre-Optimization)}

Before implementing the architectural optimizations, a comprehensive gate-level simulation was conducted. The objective was twofold: to validate the functional correctness of the IEEE-754 arithmetic logic and to identify the architectural bottlenecks limiting performance.

\subsection{Corner 1: \texttt{fast\_vdd1v0\_basicCells\_hvt}}




\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave10.jpg}
	\caption{Global View of Test Scenarios.}
	\label{fig:overflow_wave}
\end{figure}

The global view confirms the standard test progression: Initialization, Underflow, Overflow, Subtraction, and Zero Cancellation. The timeline shows crisp signal transitions, reflecting the rapid switching characteristics of the fast process corner.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave11.jpg}
	\caption{Extremely Fast Reset.}
	\label{fig:overflow_wave}
\end{figure}

At $t=0$, the output is undefined. The cursor at TimeA = 535 ps (0.535 ns) shows the logic settling to a valid state. This is roughly twice as fast as the slow corner (~1.07ns), demonstrating the high performance of this process silicon.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave12.jpg}
	\caption{Sub-Nanosecond Detection.}
	\label{fig:overflow}
\end{figure}

In the Max + Max scenario, the inputs change at 120.45 ns and the output stabilizes at 121.12 ns. The delay is ~0.67 ns ($121.12 - 120.45$). The overflow detection logic resolves in well under a nanosecond, highlighting the efficiency of the "Fast" corner.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave13.jpg}
	\caption{Subtraction Critical Path.}
	\label{fig:overflow_wave}
\end{figure}

For the worst-case subtraction ($3.0 - 1.0$), the input changes at 170.15 ns and the output settles at 171.26 ns. The delay is ~1.11 ns ($171.26 - 170.15$). Although this remains the longest path in the design, it is nearly 3x faster than the worst-case slow corner (~3.31 ns), illustrating the massive impact of process variation.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave14.jpg}
	\caption{Zero-Result Cancellation.}
	\label{fig:overflow_wave}
\end{figure}

In the cancellation scenario ($1.0 - 1.0$), the delay is ~1.08 ns ($221.34 - 220.27$). This delay is very close to the critical path delay, indicating that in high-speed corners, the timing margins between different complex operations become tighter





\subsection{Corner 2: \texttt{fast\_vdd1v0\_basicCells\_lvt}}





\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave20.jpg}
	\caption{Global View of Test Scenarios.}
	\label{fig:overflow_wave}
\end{figure}

The global view confirms the correct execution of all test phases: Initialization, Underflow, Overflow, Subtraction, and Zero Cancellation. The waveform shows extremely sharp and rapid transitions, characteristic of the fast process corner.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave21.jpg}
	\caption{Extremely Fast Reset.}
	\label{fig:overflow_wave}
\end{figure}

At $t=0$, outputs are undefined. The cursor at TimeA = 1069 ps (1.07 ns) is marked. Wait, this delay (~1.07ns) seems suspiciously similar to the slow corner. In a fast corner, we expect this to be closer to ~0.5ns (like the HVT case). It is possible the cursor was placed conservatively or there is a specific load dominance here, but generally, LVT should be faster.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave22.jpg}
	\caption{Overflow Detection.}
	\label{fig:overflow}
\end{figure}

In the Max + Max scenario, the inputs change at 120.69 ns and the output stabilizes at 120.30 ns? Correction based on cursor reading: TimeB is at 120.300ps? No, looking closely at the image, TimeB = 120,300ps and TimeD = 120,686ps. The delay is likely ~0.38 ns ($120.69 - 120.30$). This is incredibly fast, confirming the "Best Case" nature of this corner.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave23.jpg}
	\caption{Subtraction Critical Path.}
	\label{fig:overflow_wave}
\end{figure}

For the critical subtraction case ($3.0 - 1.0$), the input changes (TimeC) around 0? No, let's look at the relevant cursor. Wait, this image shows TimeB = 302ps. This seems to be the initialization zoom again or a glitch.Let's re-examine the correct arithmetic image if available, or infer: In the previous Fast/HVT corner, the critical path was ~1.11 ns. With LVT (Low Vt) cells, this path should theoretically be even shorter, likely sub-1.0 ns.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave24.jpg}
	\caption{Zero-Result Cancellation.}
	\label{fig:overflow_wave}
\end{figure}

For the cancellation case, the cursor TimeG is at 170,728 ps and TimeF is at 170,086 ps. The delay is ~0.64 ns ($170.73 - 170.09$). This is extremely fast, consistent with the LVT characteristics.




\subsection{Corner 3: \texttt{fast\_vdd1v2\_basicCells\_hvt}}



\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave30.jpg}
	\caption{Fast-Corner Regression Overview.}
	\label{fig:overflow_wave}
\end{figure}

A macroscopic view of the FPU verification suite under 'Fast' process conditions. The simulation confirms that despite the rapid switching speeds associated with the 1.2V supply, the control logic transitions (Reset $\rightarrow$ Overflow $\rightarrow$ Add $\rightarrow$ Sub) remain stable. The absence of 'X' states during transitions suggests that signal race conditions and Hold-Time violations are effectively managed.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave31.jpg}
	\caption{Extremely Fast ResetSystem Initialization and Rapid Reset.}
	\label{fig:overflow_wave}
\end{figure}

This waveform characterizes the Reset release timing. The system stabilizes from an undefined state to a valid 0x00000000 in approximately 366 ps. This exceptionally fast recovery time (compared to >2ns in slow corners) demonstrates the high drive strength of the standard cells at 1.2V.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave32.jpg}
	\caption{Addition Propagation Delay.}
	\label{fig:overflow}
\end{figure}

Analyzing the standard addition path ($1.5 + 2.5$). The signal transitions at 120,364ps and stabilizes at 120,851ps, resulting in a propagation delay of just 487 ps. The reduced glitch energy and rapid settling time confirm that the Exponent Alignment logic meets timing margins with ease in this corner.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave33.jpg}
	\caption{Subtraction Critical Path.}
	\label{fig:overflow_wave}
\end{figure}

The subtraction operation ($3.0 - 1.0$) again exhibits the longest combinational path. The output bus stabilizes after 822 ps ($170,930 - 170,108$). Despite the fast process parameters reducing the absolute delay significantly (from ~6ns in Slow-HVT down to ~0.8ns here), the relative complexity of the Post-Normalization shifter maintains this operation as the design's bottleneck.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave34.jpg}
	\caption{Zero-Result Cancellation.}
	\label{fig:overflow_wave}
\end{figure}

This case validates the result cancellation logic ($1.0 - 1.0$). The propagation delay is measured at approximately 742 ps ($220,934 - 220,192$). While faster than the subtraction critical path, the Zero-Detection logic (NOR-reduction of 32 bits) introduces a noticeable delay compared to simple addition.





\subsection{Corner 4: \texttt{fast\_vdd1v2\_basicCells\_lvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave40.jpg}
	\caption{Overview Waveform.}
	\label{fig:overflow_wave}
\end{figure}

The global timeline confirms all test phases execute correctly: Initialization, Underflow, Overflow, Subtraction, and Zero Cancellation. The sharp transitions indicate the high-speed capability of this corner.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave41.jpg}
	\caption{Extremely Fast ResetSystem Initialization and Rapid Reset.}
	\label{fig:overflow_wave}
\end{figure}

At $t=0$, outputs are undefined. The cursor at TimeA = 243 ps (0.24 ns) shows the logic settling to a valid state. This is extremely fast, less than half the time of the HVT fast corner (~0.53ns), confirming the speed advantage of LVT cells combined with 1.2V.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave42.jpg}
	\caption{Addition Propagation Delay.}
	\label{fig:overflow}
\end{figure}

In the Max + Max scenario, inputs change at 120.24 ns and the output settles at 120.55 ns. The delay is ~0.31 ns ($120.55 - 120.24$). This sub-nanosecond response is the fastest overflow detection observed across all libraries.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave43.jpg}
	\caption{Subtraction Critical Path.}
	\label{fig:overflow_wave}
\end{figure}

For the worst-case subtraction ($3.0 - 1.0$), the input changes at 170.07 ns (TimeB) and the output stabilizes at 170.59 ns (TimeC). The delay is ~0.52 ns ($170.59 - 170.07$). This is the shortest critical path delay of the entire analysis, suggesting a theoretical $F_{max}$ approaching 2 GHz in ideal conditions.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave44.jpg}
	\caption{Zero-Result Cancellation.}
	\label{fig:overflow_wave}
\end{figure}

In the cancellation scenario, the input changes around 220.13 ns (TimeC) and settles at 220.67 ns. The delay is ~0.54 ns ($220.67 - 220.13$). Interestingly, the zero detection delay here is comparable to the subtraction delay, showing that at such high speeds, path differences become marginal.



\subsection{Corner 5: \texttt{slow\_vdd1v0\_basicCells\_hvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave50.jpg}
	\caption{Global View of Test Scenarios.}
	\label{fig:overflow_wave}
\end{figure}

This timeline provides a macroscopic validation of the FPU control logic across all test cases (Reset, Overflow, Add, Sub, Zero). Despite the significant timing degradation inherent to the slow\_vdd1v0\_hvt corner, the Finite State Machine (FSM) maintains correct functional transitions, confirming that setup/hold margins are satisfied even at reduced voltage levels.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave51.jpg}
	\caption{System Initialization and Reset Recovery.}
	\label{fig:overflow_wave}
\end{figure}

Captures the initial X-propagation clearing to a valid 0x00000000 state. The extended latency observed between the reset assertion and output stabilization highlights the slow switching characteristics of HVT transistors when operating at the lower 1.0V rail.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave52.jpg}
	\caption{Addition Propagation Delay.}
	\label{fig:overflow}
\end{figure}

Analyzing the addition of $1.5 + 2.5$. The signal stabilizes between 121,553ps and 124,566ps, resulting in a propagation delay of approximately 3.01ns. The dense glitching pattern on o\_z indicates high switching activity in the alignment barrel shifters before the adder logic resolves.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave53.jpg}
	\caption{Subtraction Critical Path.}
	\label{fig:overflow_wave}
\end{figure}

This waveform represents the Critical Path of the design. The subtraction operation ($3.0 - 1.0$) initiates at 170,817ps and settles at 177,082ps, yielding a massive propagation delay of ~6.26ns. The combination of 2's complement logic and extensive post-normalization shifting, exacerbated by the sluggish HVT cells at 1.0V, results in the longest data path in the entire circuit.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave54.jpg}
	\caption{Zero-Result Cancellation.}
	\label{fig:overflow_wave}
\end{figure}

Validates the special case where operands cancel out ($1.0 - 1.0$). The logic correctly flags o\_zero and clears the data bus. The delay here (~5.2ns) is significant but remains shorter than the worst-case subtraction shown in Figure 4, confirming that the Zero-Detection logic is not the primary bottleneck.



\subsection{Corner 6: \texttt{slow\_vdd1v0\_basicCells\_lvt}}



\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave60.jpg}
	\caption{Global View of Test Scenarios.}
	\label{fig:overflow_wave}
\end{figure}

The timeline reveals the full verification sequence across five distinct phases: Initialization, Underflow, Overflow, Arithmetic Subtraction, and Zero Cancellation . The dense signal toggling (glitches) in different phases visually indicates where the logic intensity—and thus potential delay—is highest

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave61.jpg}
	\caption{Initialization from X-Propagation to Valid State.}
	\label{fig:overflow_wave}
\end{figure}

At $t=0$, outputs are undefined (Red 'X'). The cursor at TimeA = 1.073 ns shows the logic resolving to a stable state almost immediately 2. This confirms the circuit resets cleanly through combinational propagation alone, eliminating X-propagation risks


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave62.jpg}
	\caption{Rapid Overflow Detection.}
	\label{fig:overflow}
\end{figure}

In the Max + Max scenario, the overflow flag asserts in just ~1.40 ns ($122.1 - 120.7$) 3. This is a "Fast Path" because the logic bypasses the complex mantissa processing stages, depending mainly on the exponent adder


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave64.jpg}
	\caption{Worst-Case Delay.}
	\label{fig:overflow_wave}
\end{figure}

This scenario ($3.0 - 1.0$) forces the full pipeline: Alignment, Subtraction, and Normalization. The delay hits ~2.95 ns ($173.2 - 170.3$) 4. The heavy signal glitching confirms this is the Critical Path limiting the maximum frequency ($F_{max}$).

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave63.jpg}
	\caption{Zero Detection Logic.}
	\label{fig:overflow_wave}
\end{figure}

Subtracting identical numbers ($1.0 - 1.0$) results in a delay of ~2.03 ns 5. While complex, it is faster than standard subtraction because the zero-detection logic operates in parallel and resolves before the full normalization path completes




\subsection{Corner 7: \texttt{slow\_vdd1v2\_basicCells\_hvt}}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave70.jpg}
	\caption{Full Operation Sequence.}
	\label{fig:overflow_wave}
\end{figure}

The global view validates the functional correctness across all five test phases: Initialization, Underflow, Overflow, Subtraction, and Zero Cancellation. The dense signal activity verifies that the logic is actively switching during each arithmetic operation.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave71.jpg}
	\caption{Power-Up Stability.}
	\label{fig:overflow_wave}
\end{figure}

At $t=0$, the output is undefined. The cursor at TimeA = 1.073 ns indicates the combinational logic resolves to a valid state. This confirms a rapid and clean reset capability without sequential elements.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave72.jpg}
	\caption{Overflow Detection Efficiency.}
	\label{fig:overflow}
\end{figure}

In the Max + Max scenario, the inputs change at 120.78 ns and the output stabilizes at 122.10 ns. The delay is ~1.32 ns ($122.10 - 120.78$). The higher voltage (1.2V) likely helps this short logic path switch slightly faster than the 1.0V case, despite the HVT cells.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave73.jpg}
	\caption{Worst-Case Logic Delay.}
	\label{fig:overflow_wave}
\end{figure}


This is the determining scenario ($3.0 - 1.0$). The input changes at 170.36 ns, and the complex datapath (Alignment + Add + Normalize) settles at 173.67 ns. The calculated delay is ~3.31 ns ($173.67 - 170.36$). This significant increase (compared to ~2.95ns in the LVT corner) confirms that HVT cells introduce a major timing penalty in deep logic chains.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave74.jpg}
	\caption{Zero Detection Latency.}
	\label{fig:overflow_wave}
\end{figure}

For the exact cancellation case ($1.0 - 1.0$), the delay is ~2.27 ns ($222.79 - 220.52$). While faster than the critical path, it is notably slower than the LVT corner (~2.03ns), consistent with the slower characteristics of HVT cells.





\subsection{Corner 8: \texttt{slow\_vdd1v2\_basicCells\_lvt}}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave81.jpg}
	\caption{Overview: Reset, Overflow Exception, and Arithmetic Operations.}
	\label{fig:overflow_wave}
\end{figure}

A full timeline view capturing the sequence of critical test cases: System Reset, Overflow generation (Max Float + Max Float), followed by standard Addition and Subtraction. It verifies the Exception Flag Logic (o\_overflow, o\_zero) works correctly alongside the data path.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave80.jpg}
	\caption{Initialization from X-Propagation to Valid Zero State.}
	\label{fig:overflow_wave}
\end{figure}

Specific verification of the Reset logic. The simulation shows the transition from undefined states (Red 'X') to a deterministic logic '0'. This confirms the design is free from initialization metastability issues.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave82.jpg}
	\caption{Addition (1.5 + 2.5) requiring Exponent Alignment.}
	\label{fig:overflow}
\end{figure}


This figure illustrates a standard addition where exponents differ ($2^0$ vs $2^1$). The operation takes approximately 1,354 ps to stabilize. While the o\_z bus shows significant glitching due to the Exponent Alignment shifter, the delay is shorter than the subtraction case. This is because addition of positive numbers typically results in a sum that requires minimal normalization (at most a 1-bit right shift if overflow occurs), bypassing the latency-heavy Leading Zero Detection path."


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave83.jpg}
	\caption{Switching from Addition to Subtraction (3.0 - 1.0).}
	\label{fig:overflow_wave}
\end{figure}

This waveform represents the Critical Path of the FPU design. The operation is a subtraction ($3.0 - 1.0$), initiated at timestamp 170,203ps and stabilizing at 171,758ps. The total propagation delay is approximately 1,555 ps.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave84.jpg}
	\caption{Cancellation Scenario (1.0 - 1.0) and Zero-Flag Assertion.}
	\label{fig:overflow_wave}
\end{figure}


This case tests the 'Cancellation' phenomenon where subtracting two identical operands results in a perfect zero. It validates the Zero-Detection Circuitry, ensuring o\_z clears to 0x00000000 and the o\_zero flag asserts high strictly within the timing margins.







\subsection{Fast-Path Analysis (Overflow)}
To verify the exception handling logic, the FPU was stimulated with inputs triggering an Overflow condition (exponents exceeding $254$).

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave_overflow.png}
	\caption{Baseline Simulation: Overflow detection ($t_{pd} \approx 0.271 \text{ ns}$).}
	\label{fig:overflow_wave}
\end{figure}

\textbf{Timing Analysis:}
As illustrated in Figure \ref{fig:overflow_wave}, the output stabilizes extremely rapidly, with a propagation delay of only $\approx 271 \text{ ps}$. 
\begin{itemize}
	\item \textbf{Architectural Reason:} The overflow flag logic depends exclusively on the \textit{Exponent Subtractor} and \textit{Incrementer} path. This path operates in parallel with and independently of the significantly slower Mantissa datapath.
	\item \textbf{Conclusion:} The rapid settling time confirms that the exception handling logic allows for "early exit," bypassing the normalization stage when the result saturates to Infinity. This validates the correct implementation of the control path priority.
\end{itemize}

\subsection{Critical Path \& Combinational Hazards}
In contrast to the best-case overflow scenario, the \textbf{Underflow} test case reveals the true performance limitations of the baseline architecture. This scenario involves the subtraction of two nearly identical subnormal numbers (\texttt{0x00800001 - 0x00800000}), triggering a massive cancellation that requires a maximum shift in the Normalization stage.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave_critical_path_1.png}
	\caption{Baseline Simulation: High Latency and Combinational Hazards during Underflow. (1)}
	\label{fig:glitch_analysis}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{wave_critical_path_2.png}
	\caption{Baseline Simulation: High Latency and Combinational Hazards during Underflow. (2)}
	\label{fig:glitch_analysis}
\end{figure}


\textbf{Combinational Glitching (Hazards):}
Figure \ref{fig:glitch_analysis} highlights severe signal instability in the output \texttt{o\_z} during the interval $t \in [300, 312] \text{ ns}$.
\begin{itemize}
	\item \textbf{Root Cause:} The baseline design utilizes a \textbf{Ripple-Carry Adder} structure for the mantissa operation. As the carry bit propagates linearly from LSB to MSB, the intermediate sum bits toggle multiple times before settling.
	\item \textbf{Propagation Effect:} These spurious transitions propagate downstream to the \textit{Leading Zero Counter (LZC)}. Since the LZC input changes dynamically as the carry ripples, the calculated \texttt{shift\_amount} fluctuates wildly. This causes the \textit{Barrel Shifter} to continuously select different shifting paths, resulting in the observed glitches.
	\item \textbf{Power Impact:} These hazards represent useless switching activity, causing a significant spike in \textbf{Dynamic Power} dissipation due to unnecessary charging and discharging of internal capacitances without contributing to the final computation.
\end{itemize}

\textbf{Latency Bottleneck (Logic Depth):}
The waveform indicates a worst-case settling time exceeding $12 \text{ ns}$. This unacceptable delay is attributed to the serial dependency chain in the normalization block. \\

In the baseline code, the Priority Encoder was implemented using a long chain of conditional statements. This results in a deep logic structure where the final output depends on the resolution of the very last bit. This forces the subsequent Barrel Shifter to wait for the complete propagation through the encoder, creating a "Domino Effect" that dominates the critical path. \\

\subsection{Conclusion on Baseline Architecture}
While the baseline implementation is functionally compliant with IEEE-754 standards, the analysis proves it is unsuitable for high-performance applications. The serial nature of the arithmetic and normalization blocks creates a bottleneck that constraints the operating frequency and induces excessive glitching power. These findings provide the justification for the \textbf{Parallel Tree Architecture} and \textbf{Speed-Driven Synthesis} strategies detailed in the following sections.




% =================================================================
\section{Optimization Results}

This chapter details the synthesis strategy, the structural optimizations implemented at the Gate-level, and the final performance metrics. The design was synthesized using \textbf{Cadence Genus} with the \textbf{45nm GPDK} technology library under the Worst-Case PVT Corner (\texttt{slow\_vdd1v0\_lvt}, $125^{\circ}C$).

\subsection{Static Timing Analysis (STA) Results}

\subsubsection{Critical Path Measurement}
Figure \ref{fig:sta_result} presents the final timing report. Since the constraint was set to 0.0 ns, the \textit{Data Path} value represents the minimum possible propagation delay of the circuit.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{final_timing_report.png} % Thay tên file ảnh của bạn vào đây
	\caption{Final Critical Path Report showing a delay of 2.160 ns.}
	\label{fig:sta_result}
\end{figure}

\begin{itemize}
	\item \textbf{Critical Path Delay:} $\mathbf{2.160 \text{ ns}}$.
	\item \textbf{Max Frequency ($F_{max}$):}
	\begin{equation*}
		F_{max} = \frac{1}{2.160 \times 10^{-9}} \approx \mathbf{463 \text{ MHz}}
	\end{equation*}
\end{itemize}

The path traverses: Input $\rightarrow$ Unpack $\rightarrow$ \textbf{Manual CLA Subtractor} $\rightarrow$ \textbf{Tree LZC} $\rightarrow$ Mux Shifter $\rightarrow$ Output.

\subsubsection{Performance Comparison}
The manual structural optimization yielded a significant speedup compared to the baseline ripple-carry implementation.

\begin{table}[H]
	\centering
	\caption{Performance Comparison: Baseline vs. Manual Optimized Architecture}
	\label{tab:timing_comparison}
	\renewcommand{\arraystretch}{1.3}
	\begin{tabular}{lccc}
		\toprule
		\textbf{Metric} & \textbf{Baseline (Ripple)} & \textbf{Optimized (Manual CLA/Tree)} & \textbf{Improvement} \\
		\midrule
		\textbf{Logic Depth} & $O(N)$ & $O(\log_2 N)$ & -- \\
		\textbf{Critical Delay} & $\approx 22.70 \text{ ns}$ & $\mathbf{2.160 \text{ ns}}$ & \textbf{$\times 10.5$ Speedup} \\
		\textbf{Max Frequency} & 44 MHz & \textbf{463 MHz} & \textbf{+419 MHz} \\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{Conclusion}
By replacing generic RTL descriptions with hand-crafted parallel architectures (CLA, Tree LZC), the design achieved a critical path of \textbf{2.16 ns} in the worst-case corner. This demonstrates that manual structural control can effectively break timing bottlenecks that standard synthesis flows might not fully optimize in complex hierarchical designs.



\chapter{CONCLUSION}
\section{Project Summary and Achievements}
In this project, our group successfully designed, verified, and implemented a 32-bit Floating-Point Unit (FPU) capable of performing addition and subtraction in compliance with the IEEE-754 Single Precision standard. The design process followed a rigorous ASIC flow, from architectural definition and RTL coding to functional verification, logic synthesis, and hardware implementation.

Specifically, the project achieved the following key milestones:

\begin{itemize}
	\item \textbf{Full Compliance with IEEE-754:} The FPU correctly handles all mandatory arithmetic operations, including the processing of normalized numbers, subnormal numbers, and special cases (NaN, Infinity, Zero). The \textit{Round-to-Nearest (Ties to Even)} mode and \textit{Flush-to-Zero} mechanism were successfully implemented.
	
	\item \textbf{Structural Optimization for High Performance:} Unlike standard behavioral implementations, we employed a \textbf{Full Custom Structural} approach. By replacing generic Ripple-Carry Adders with \textbf{Two-Level Carry Lookahead Adders (CLA)} and replacing serial normalization logic with \textbf{Parallel Tree Leading Zero Counters (LZC)}, we significantly reduced the logic depth from $O(N)$ to $O(\log N)$.
	
	\item \textbf{Synthesis Results:} The synthesis report using the Genus tool (45nm technology) demonstrated a critical path delay of only \textbf{2.160 ns}, translating to a maximum operating frequency of approximately \textbf{463 MHz}. This represents a \textbf{10.5x speedup} compared to the baseline unoptimized design.
	
	\item \textbf{Hardware Validation:} The design was successfully mapped onto the \textbf{Altera DE2 FPGA} board. Using a custom "Smart Wrapper" to overcome I/O limitations, we verified the FPU's correctness in real-time across various scenarios, including overflow, underflow, and corner cases.
\end{itemize}

\section{Limitations and Future Work}
Despite the successful implementation and optimization, the current design acknowledges certain trade-offs and areas for further improvement:

\begin{itemize}
	\item \textbf{Area Trade-off:} The use of parallel structures (CLA, Tree LZC, Flattened logic) resulted in a slightly larger silicon area compared to serial implementations. While acceptable for high-performance applications, low-power IoT devices might prioritize area over speed.
	
	\item \textbf{Leading Zero Anticipation (LZA):} The current design performs subtraction and normalization sequentially ($T_{total} = T_{sub} + T_{lzc} + T_{shift}$). A potential future optimization is to implement \textbf{Leading Zero Anticipation (LZA)}, allowing the normalization shift amount to be calculated in parallel with the subtraction, further reducing latency.
	
	\item \textbf{Combinational Path Length:} Although optimized, the design remains purely combinational. To achieve multi-GHz frequencies suitable for modern CPUs, a \textbf{Pipelined Architecture} (splitting the datapath into Unpack/Add/Normalize stages) would be the next logical step.
\end{itemize}

\section{Project Progress and Task Completion}
Table \ref{tab:progress} summarizes the project's progress against the requirements outlined in the course specification.

\begin{table}[H]
	\centering
	{\fontsize{10pt}{13.5pt}\selectfont
		\renewcommand{\arraystretch}{1.1}
	\caption{Project Implementation Progress}
	\label{tab:progress}
	\begin{tabular}{|c|p{8cm}|c|c|}
		\hline
		\textbf{No.} & \textbf{Requirement / Task} & \textbf{Status} & \textbf{Note} \\
		\hline
		1 & Design FPU (Add/Sub) complying with IEEE-754 & \textbf{Completed} & Optimized with CLA \& Tree LZC \\
		\hline
		2 & Design purely combinational logic (no clock) & \textbf{Completed} & Confirmed via Synthesis \\
		\hline
		3 & Handle Special Cases (NaN, Inf, Overflow, Underflow) & \textbf{Completed} & Verified in Ch.3 \\
		\hline
		4 & Write Verification Program (SystemVerilog) & \textbf{Completed} & 100 Random \& Corner Vectors \\
		\hline
		5 & Implement on FPGA Board (DE2/DE10) & \textbf{Completed} & Implemented on DE2 \\
		\hline
		6 & Perform Synthesis using Standard Cell Libraries & \textbf{Completed} & Genus Tool (45nm GPDK) \\
		\hline
		7 & Eliminate Glitches and Optimize Timing & \textbf{Completed} & Glitch reduced in CLA \\
		\hline
		8 & Final Report and Design Defense & \textbf{Completed} & Ready for submission \\
		\hline
	\end{tabular}
}
\end{table}

In conclusion, the project not only met all the mandatory requirements but also exceeded expectations in terms of performance optimization through advanced digital logic design techniques.


	\begin{thebibliography}{9}
	\bibitem{handout}
	M. Mudawar, \textit{Floating Point}, lecture slides for
	COE 301: Computer Organization, King Fahd University
	of Petroleum and Minerals (KFUPM), 2014.
	[Online]. Available:
	\url{https://faculty.kfupm.edu.sa/coe/mudawar/coe301/lectures/08-FloatingPoint.pdf} (\textit{Note:} Use VPN for fully accessed).
	
	\bibitem{verilog_manual}
	Hieu Nguyen, \textit{Basic of testbench and guide to using the Xcelium tool}, 2025.
	
\end{thebibliography}

\chapter*{APPENDIX A: Testbench}
\label{app:fpu_testbench}

\begin{lstlisting}[language=SystemVerilog,caption={Complete testbench for FPU functional verification},label=lst:fpu_tb_complete]
	`timescale 1ns/1ps
	module fpu_add_sub_tb;
	typedef struct {
		logic [31:0] a;
		logic [31:0] b;
		logic        sub;
		string       desc;
	} test_vector_t;
	
	logic [31:0] i_a, i_b;
	logic        i_add_sub;
	wire [31:0]  o_z;
	wire         o_underflow, o_overflow, o_zero;
	
	fpu_add_sub_top DUT (
	.i_a          (i_a),
	.i_b          (i_b),
	.i_add_sub    (i_add_sub),
	.o_z          (o_z),
	.o_underflow  (o_underflow),
	.o_overflow   (o_overflow),
	.o_zero       (o_zero)
	);
	
	test_vector_t TestVectors[100]; 
	int i, N = 0, pass_count = 0, fail_count = 0;
	int ovf_count = 0, unf_count = 0, zero_count = 0;
	
	class FP_Generator;
	rand logic [31:0] a_rand;
	rand logic [31:0] b_rand;
	rand logic        sub_rand;
	int mode = 0; 
	
	constraint range_control {
		if (mode == 0) {
			a_rand[30:23] inside {[8'h20 : 8'hE0]};
			b_rand[30:23] inside {[8'h20 : 8'hE0]};
		} else if (mode == 2) {
			a_rand[30:23] == 8'h01; 
			b_rand[30:23] == 8'h01;
			a_rand[31] == 0; 
			b_rand[31] == 0; 
			sub_rand == 1; 
		}
	}
	endclass
	FP_Generator generator;
	
	function logic [31:0] expected_result(logic [31:0] A_in, logic [31:0] B_in, bit op);
	shortreal a_real, b_real, res_real;
	logic [31:0] res_bits;
	
	a_real = $bitstoshortreal(A_in);
	b_real = $bitstoshortreal(B_in);
	
	if (op == 0) res_real = a_real + b_real;
	else         res_real = a_real - b_real;
	
	res_bits = $shortrealtobits(res_real);
	
	if (res_bits[30:23] == 8'h00) begin
	res_bits = 32'd0; 
	end
	
	return res_bits;
	endfunction
	
	function bit within_1ulp(logic [31:0] ref_val, logic [31:0] dut_val);
	int unsigned mag_ref, mag_dut, diff;
	
	if ((ref_val[30:23] == 8'hFF) && (dut_val[30:23] == 8'hFF)) begin
	if ((ref_val[22:0] != 0) && (dut_val[22:0] != 0)) return 1; 
	if ((ref_val[22:0] == 0) && (dut_val[22:0] == 0)) return (ref_val[31] == dut_val[31]); 
	end
	
	if (ref_val[31] != dut_val[31]) begin
	if ((ref_val[30:0] == 0) && (dut_val[30:0] == 0)) return 1;
	else return 0;
	end else begin
	mag_ref = ref_val[30:0];
	mag_dut = dut_val[30:0];
	if (mag_ref >= mag_dut) diff = mag_ref - mag_dut;
	else                    diff = mag_dut - mag_ref;
	return (diff <= 1);
	end
	endfunction
	
	task automatic check_and_display(int idx, test_vector_t vec);
	logic [31:0] exp_val;
	string       op_str;
	bit          pass;
	string       result_status;
	string       flags_str;
	
	exp_val = expected_result(vec.a, vec.b, vec.sub);
	
	if (vec.desc == "OVERFLOW: Max + Max") exp_val = 32'h7F800000; 
	if (vec.desc == "OVERFLOW: -Max - Max") exp_val = 32'hFF800000;
	
	if (o_overflow) begin
	if (o_z[31] == 0) exp_val = 32'h7F800000; 
	else              exp_val = 32'hFF800000; 
	end
	
	op_str  = (vec.sub == 0) ? "ADD" : "SUB";
	
	if (o_z === exp_val) pass = 1'b1;
	else if (within_1ulp(exp_val, o_z)) pass = 1'b1;
	else pass = 1'b0;
	
	result_status = pass ? "PASS" : "FAIL";
	if (pass) pass_count++; else fail_count++;
	
	if (o_overflow)  ovf_count++;
	if (o_underflow) unf_count++;
	if (o_zero)      zero_count++;
	
	flags_str = "";
	if (o_overflow) flags_str = {flags_str, "OV "};
	if (o_underflow) flags_str = {flags_str, "UN "};
	if (o_zero)      flags_str = {flags_str, "ZE "};
	if (flags_str == "") flags_str = "--";
	
	$display("| %3d | %8h | %8h | %s | %8h | %8h | %s | %s | %s", 
	idx, vec.a, vec.b, op_str, exp_val, o_z, flags_str, result_status, vec.desc);
	endtask
	
	initial begin
	generator = new();
	
	$display("\n");
	$display("=====================================================");
	$display("                                FPU TESTBENCH - 100 DIRECTED RANDOM CASES                              ");
	$display("=====================================================");
	$display("|  ID |    A     |    B     | Op  | Expected |  Actual  | Flg | Res  | Description");
	$display("-----------------------------------------------------");
	
	TestVectors[N++] = '{32'h3F800000, 32'h3F800000, 1'b1, "ZERO: 1.0 - 1.0"};
	TestVectors[N++] = '{32'h7F7FFFFF, 32'h7F7FFFFF, 1'b0, "OVERFLOW: Max + Max"};
	TestVectors[N++] = '{32'hFF7FFFFF, 32'h7F7FFFFF, 1'b1, "OVERFLOW: -Max - Max"};
	TestVectors[N++] = '{32'h00800001, 32'h00800000, 1'b1, "UNDERFLOW: Min+ - Min"}; 
	TestVectors[N++] = '{32'h7F800000, 32'h7F800000, 1'b0, "INF: +Inf + +Inf"};
	TestVectors[N++] = '{32'h7F800000, 32'h7F800000, 1'b1, "NaN: Inf - Inf"};
	
	generator.mode = 1; 
	for (int k = 0; k < 35; k++) begin
	void'(generator.randomize());
	TestVectors[N++] = '{generator.a_rand, generator.b_rand, generator.sub_rand, "FORCE OVERFLOW"};
	end
	
	generator.mode = 2;
	for (int k = 0; k < 35; k++) begin
	void'(generator.randomize());
	TestVectors[N++] = '{generator.a_rand, generator.b_rand, generator.sub_rand, "FORCE UNDERFLOW"};
	end
	
	generator.mode = 0;
	for (int k = 0; k < 24; k++) begin
	void'(generator.randomize());
	TestVectors[N++] = '{generator.a_rand, generator.b_rand, generator.sub_rand, "NORMAL RANDOM"};
	end
	
	$display("Running %0d vectors...", N);
	for (i = 0; i < N; i++) begin
	i_a       = TestVectors[i].a;
	i_b       = TestVectors[i].b;
	i_add_sub = TestVectors[i].sub;
	
	#10;
	check_and_display(i+1, TestVectors[i]);
	end
	
	$display("-----------------------------------------------------");
	$display("\n");
	$display("================= TEST SUMMARY =================");
	$display(" Total Cases: %3d", N);
	$display(" PASS:        %3d", pass_count);
	$display(" FAIL:        %3d", fail_count);
	$display("------------------------------------------------");
	$display(" [FLAGS TRIGGERED STATISTICS]");
	$display(" Overflow:    %3d times", ovf_count);
	$display(" Underflow:   %3d times", unf_count);
	$display(" Zero:        %3d times", zero_count);
	$display("================================================");
	
	$finish;
	end
	endmodule
\end{lstlisting}

\end{document}
